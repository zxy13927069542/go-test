### 常用命令

#### go build

`go build test.go`会在当前目录下生成`test.exe`可执行文件



#### go clean

在指定目录下执行`go clean`，可以删除编译生成的可执行文件1



#### go run

`go run`不会在运行目录下生成任何文件，可执行文件被放在临时文件中被执行



#### go fmt

`go fmt 文件名或包名`可以格式化代码



#### godoc



##### 下载godoc

`godoc`在go1.13后需要自己下载

```go
//启用go module
go env -w GO111MODULE=on

//配置 GOPROXY 选一个就行
//阿里云
go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct # 
//官方
go env -w GOPROXY=https://goproxy.io,direct

//下载go doc
go get golang.org/x/tools/cmd/godoc
```



##### 使用godoc

使用`godoc -http=:6060`命令即可开启文档服务器，访问`http://localhost:6060`即可看到



#### go mod init 项目名



### 包

- 每个包都在相同的目录，不能把多个包放在相同的目录，也不能把同一个包的文件拆到多个不同的目录，同一目录下的所有go代码文件都必须同属一个包
- 包名全小写，惯例为目录名
- main包中的main函数为程序入口，生成的可执行文件名为main包所在目录



#### 命名导入

```go
import calc "go-test/ying/package"

func main() {
	calc.Reduce(3,4)
}
```



#### 匿名导入

```go
import _ "go-test/ying/package"
```

> **当想导入一个不在代码中使用的包时，可以使用空白标识符`_`来匿名导包从而不报错**



### Delve

- ```
  Goland Debug报错:
  	Version of Delve is too old for this version of Go (maximum supported version 1.12, suppress this error with --check-go-version=false)
  	即Delve版本过旧或者压根没有Deve
  ```

  - 解决措施：下载一个高版本或新的Delve,并在goland中配置其路径

    1. ```
       go get -u github.com/go-delve/delve/cmd/dlv	//下载dlv到本地
       ```

    2. 用everything搜索delve.exe找到其路径，并克隆到Go安装路径的bin目录下

    3. 打开 `Hele->Edit Customer Properties`,若提示文件不存在，点击创建。然后在新加一行 

       ```
       dlv.path=Go的安装路径/bin/dlv.exe
       ```

        重启就可以了





## 数组

- 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是**数组大小不可变化**
- 数组为值类型



### 数组定义

```go
var s1 [3]int
var s2 [4]int
fmt.Printf("s1的类型为%T\n", s1) //s1的类型为[3]int
fmt.Printf("s2的类型为%T\n", s2) //s2的类型为[4]int
fmt.Printf("%v\n", s1)	//[0 0 0]
fmt.Printf("%v\n", s2)	//[0 0 0 0]
```

> **数组的长度为类型的一部分，长度不同，即使是同一数据类型的数组类型也不同**



### 数组初始化

```go
//数组初始化

//第一种
var s3 [3]int = [3]int{1, 1, 1}
fmt.Println(s3)

//第二种
s4 := [3]int{1, 1, 1}
fmt.Println(s4)

//第三种
s5 := [...]int{1, 1, 1}
fmt.Printf("s5的类型为%T\n值为%v\n", s5, s5) //类型为[3]int

//与第三种区分，这种初始化方式是切片，不是数组
s6 := []int{1, 1, 1}
fmt.Printf("s6的类型为%T\n值为%v\n", s6, s6) //类型为[]int,切片，长度可变

//第四种
s7 := [5]int{0: 1, 4: 3}               //根据索引来进行初始化
fmt.Printf("s7的类型为%T\n值为%v\n", s7, s7) //[1 0 0 0 3]
```



### 数据遍历

- 普通for循环

  ```go
  s8 := [...]int{3, 4, 5, 6}
  //普通for循环
  for i := 0; i < len(s8); i++ {	
      fmt.Println(s8[i])
  }
  ```

  > 可以使用内置函数`len`来获取数组长度

- for range循环

  ```go
  s8 := [...]int{3, 4, 5, 6}
  //for range循环
  for i1, v1 := range s8 {
      fmt.Printf("\n索引为%v的值为%v\n", i1, v1)
  }
  ```

  > for index, value := range s8



### 二维数组

```go
arr := [3][2]string{
    {"数学", "语文"},
    {"篮球", "足球"},
    {"画画", "唱歌"},
}
fmt.Printf("%v\n",arr)	//[[数学 语文] [篮球 足球] [画画 唱歌]]

//使用普通for循环遍历
for i := 0; i < len(arr); i++ {
    for y := 0; y < len(arr[i]); y++ {
        fmt.Println(arr[i][y])
    }
}

//使用for range遍历
for _, v := range arr {
    for _, v1 := range v {
        fmt.Println(v1)
    }
}
```



### 数组的复制

因为数组是值类型，所以数组可以像一个值一样赋值给类型相同的数组

```go
arr1 := [3]string {"李宁", "塞班", "鸿星尔克"}
var arr2 [3]string
arr2 = arr1
fmt.Printf("%p\n",&arr1)	//0xc00007c390
fmt.Printf("%p\n",&arr2)	//0xc00007c3c0
arr2[0] = "白雨"
fmt.Println(arr1)	//[李宁 塞班 鸿星尔克]
fmt.Println(arr2)	//[白雨 塞班 鸿星尔克]
```

> **使用%p可以输出变量的地址，可以看到arr1与arr2的变量地址不一样**
>
> **修改arr2后，arr1并没有改变**



### 在函数间传递数组

**根据内存和性能来看，在函数间传递数组是一件开销很大的操作。在函数间传递变量时，总是以值的方式传递的，所以对于数组来说，一般是使用指针来进行数组的传递**

```go
var arr1 [300]int
func foo(arr *[300]int)
foo(&arr1)
```



## 切片

- 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

- 切片是一个**引用类型**，它的内部结构包含`地址`、`长度`和`容量`
- 切片的类型不像数组一样与长度挂钩，例如`var arr []int`,则切片的类型为`[]int`



### 切片定义

```go
//切片为引用类型，未初始化的切片为nil，相当于null
var s2 []int
fmt.Println(s2)	//[]
fmt.Println(s2 == nil)	//true
fmt.Printf("s2的长度为:%d,容量为:%d\n", len(s2), cap(s2)) //s2的长度为:0,容量为:0
s2[0] = 1	//未初始化的切片无法赋值，会报错
var s3 []int
fmt.Println(s2 == s3)	//会报错
```

> **对于引用类型来说，其零值就是nil，另外，切片之间不支持直接比较**
>
> **可以使用内置函数`len`来获取切片的元素个数**
>
> **可以使用内置函数`cap`来获取切片的容量，超过容量切片便会自动扩容**
>
> **未初始化的切片无法赋值，会报错**



### 切片的初始化

- 直接初始化

  ```go
  //定义一个切片
  s1 := []int{1, 2}
  //修改切片
  s1[0] = 0
  fmt.Println(s1)
  fmt.Printf("s1的长度为:%d,容量为:%d\n", len(s1), cap(s1)) //s1的长度为:2,容量为:2
  fmt.Println(s1 == nil)	//false
  
  //初始化过的切片不为nil，即使长度与容量均为0
  s6 := []int{}
  fmt.Printf("s6的长度为:%d,容量为:%d\n", len(s6), cap(s6)) //s6的长度为:0,容量为:0
  fmt.Println(s6 == nil) //false
  ```

  > **直接初始化的切片长度与容量默认相等**
  >
  > **初始化过的切片不为nil，即使长度与容量均为0**

- 使用make初始化

  `make函数`可以指定切片的长度，容量

  ```go
  s5 := make([]int, 5, 10) //s5的类型为[]int，长度为5，容量为10
  fmt.Printf("值为:%v\n",s5)	//[0 0 0 0 0]
  ```

- 由数组得到切片，会将数组作为切片的底层数组，两者会互相影响

  ```go
  //由数组得到切片
  s3 := [...]int{3, 3, 3}
  s4 := s3[:]
  s4[0] = 1 //数组相应的值也会发生变化
  fmt.Println(s3, s4)
  ```

- 由切片得到切片,**两个切片指向同一个底层数组，因此也会互相影响**

  ```go
  s1 := []int{3,3,3,3}
  s2 := s1[:2]
  fmt.Printf("s1的指针: %p, s1的值: %v\n", &s1, s1)	//s1的指针: 0xc000004078, s1的值: [3 3 3 3]
  fmt.Printf("s2的指针: %p, s2的值: %v\n", &s2, s2)	//s2的指针: 0xc000004090, s2的值: [3 3]
  //修改s1
  s1[0] = 1
  fmt.Printf("s1的值: %v\n", s1)	//s1的值: [1 3 3 3]
  fmt.Printf("s2的值: %v\n", s2)	//s2的值: [1 3]
  ```

  

### 切片表达式

```go
s4 := s3[a:b]	//从数组中截取(a,b]的段落作为切片的值
s4 := s3[a:]	//截取从下标a开始的数组段落
s4 := s3[:b]	//从头截取数组段落直到数组下标b
s4 := s3[:]		//截取数组的全部
```



### 切片的长度

切片长度是指当前切片中有多少个元素，可以用`len(s1)`获取



### 切片的容量

切片的容量指当前切片最多能存储多少个元素，当容量不足时会自动扩容，容量可以用`cap(s1)`获取



### 切片的本质

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

举个例子，现在有一个数组`a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}`，切片`s1 := a[:5]`，相应示意图如下。![slice_01](https://www.liwenzhou.com/images/Go/slice/slice_01.png)切片`s2 := a[3:6]`，相应示意图如下：![slice_02](https://www.liwenzhou.com/images/Go/slice/slice_02.png)



### 切片判空

判断切片是否为空，应该使用`len(s1) == 0`来判断，而不是`s1 == nil`



### 切片的赋值拷贝

切片为引用类型，将切片直接赋值给另一个切片会导致两个切片指向同一个底层数组，修改其中一个切片会导致另一个切片的改变

```go
s1 := make([]int, 3, 9)
fmt.Println("修改前s1:",s1)	//修改前s1: [0 0 0]
s2 := s1
fmt.Println("修改前s2:",s2)	//修改前s2: [0 0 0]
//修改s2
s2[0] = 1
fmt.Println("修改后s1:",s1)	//修改后s1: [1 0 0]
fmt.Println("修改后s2:",s2)	//修改后s2: [1 0 0]
```

使用内置函数`copy()`进行切片拷贝

```go
copy(destSlice, srcSlice []T)
```

```go
s1 := []int{3,3,3}
//需要s2容量足够才能copy，copy并不会进行扩容操作
s2 := make([]int, 3, 3)
fmt.Printf("copy前s1: %v\n",s1)
copy(s2, s1)
fmt.Printf("copy后s1: %v，s1的地址：%p\n",s1, &s1)
fmt.Printf("copy后s2: %v, s2的地址: %p\n",s2, &s2)
```



### 切片遍历

切片遍历与数组遍历一致，都可以用普通for循环遍历和for range 遍历，**这里有一点要注意，for range会创建每个元素的副本，所以如果切片元素为值类型的话，修改是无效的。**



### append

切片可以使用`append()`函数来新增元素，在使用`append()`时如果切片容量不足会自动扩容，在使用`append()`会往底层数组新增元素，如果底层数组的容量足够，则直接新增，无需扩容，如果底层数组容量不足，此时的底层数组就会更换，扩容到一个容量更大的底层数组去。

```
func append(slice []Type, elems ...Type) []Type
```

```go
//使用append函数扩容,扩容后容量依照策略进行增加
s9 := make([]int, 3, 3)
fmt.Printf("len:%d,cap:%d,value:%v\n", len(s9), cap(s9), s9)	//len:3,cap:3,value:[0 0 0]
s9 = append(s9, 3, 3)
fmt.Printf("len:%d,cap:%d,value:%v\n", len(s9), cap(s9), s9)	//len:5,cap:6,value:[0 0 0 3 3]
```

> 切片的扩容策略通常为2倍

- 新增一个元素

  ```go
  s1 = append(s1, 3)
  ```

- 新增多个元素

  ```
  s1 = append(s1, 3, 3)
  ```

- 使用切片来新增元素

  ```
  arr := []int{3, 3, 3}
  s1 = append(s1, arr...)	//...表示把切片拆分成一个一个的元素
  ```

  > 无法使用数组来新增元素



使用切片扩容后原切片仍然存在

```go
s1 := make([]int, 3, 3)
fmt.Printf("扩容前s1: %v\n", s1)	//扩容前s1: [0 0 0]
s2 := append(s1, 3)
fmt.Printf("扩容后s1: %v\n", s1)	//扩容后s1: [0 0 0]
fmt.Printf("扩容后s2: %v\n", s2)	//扩容后s2: [0 0 0 3]

s3 := append(s1, s2...)
fmt.Printf("再一次扩容后s1: %v\n", s1)	//再一次扩容后s1: [0 0 0]
fmt.Printf("再一次扩容后s2: %v\n", s2)	//再一次扩容后s2: [0 0 0 3]
fmt.Printf("再一次扩容后s3: %v\n", s3)	//再一次扩容后s3: [0 0 0 0 0 0 3]
```



### 从切片中删除元素

Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：

```go
func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
```

总结一下就是：要从切片a中删除索引为`index`的元素，操作方法是`a = append(a[:index], a[index+1:]...)`



## map

- Go语言提供的映射关系容器为`map`，其内部使用哈希表`hash`实现，相当于java的`HashMap`
- map是**引用类型**



### map的定义

map为引用类型，**如果不经初始化分配内存则为`nil`,此时往里存数据会报错**

```go
var m1 map[int]string
fmt.Println(m1 == nil)	//true
map[0] = "AAA"	//会报错
```



### map的初始化

map定义之后还需要分配内存空间来进行初始化，类似于java中的new操作，所以**使用make来分配内存空间进行初始化**

```go
s1 := make(map[int]string, 10) //第一个参数为map类型，第二个参数为map容量，超出容量会动态扩容
s1[0] = "AAA"	//初始化之后可以往map中存储元素

//在定义时就填充元素
m := map[int]string {
    3 : "郑晓颖",
    10 : "郑晓燕",
    001 : "郑兵颖",	//相当于 1 : "郑兵颖"
}
```



### 判断某个键是否存在

```go
m := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
    3 : "郑速贤",
    4 : "郑周珊",
}
//判断key为1的键值对是否存在，并用val接收值，用exit接收存在结果，存在则为true，不存在则为false
val, exit := m[1]
if exit {
    fmt.Println(val)	//郑晓颖
}
```



### map的遍历

由于map是基于`hash`实现的，其内部存储元素是无序的，因此无法用普通`for`循环遍历，只能用`for range`遍历

```go
s1 := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
}
//1.map的遍历
//2.map中元素无序，无法用普通for循环遍历，需要使用for range遍历
for key, value := range s1 {
    fmt.Println(key, value)
    //直接修改range返回的key和value是无效的，返回的key和value只是副本
    value = "郑周珊"
    //这种修改才有效
    s1[key] = "郑速贤"
}
```

- 与切片一致，`for range`返回的`key`和`value`是副本，直接修改反映不到map中



### 使用delete删除键值对

删除map中的键值对需要使用内置函数`delete()`来删除

```go
func delete(m map[Type]Type1, key Type)
```

```go
s1 := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
}
//内建函数delete按照指定的键将元素从映射中删除。若m为nil或无此元素，delete不进行操作。
delete(s1, 1)
fmt.Println(s1)	//map[2:郑兵颖]
```



### 按照指定顺序遍历map

```go
/**
生成随机数的value，并按照key的顺序打印键值对
 */
func main() {
   //1.测试printOrderly函数
   //2.初始化随机数种子
   rand.Seed(time.Now().UnixNano())
   //3.初始化map
   s2 := make(map[string]int, 20)
   //4.往map中填充元素
   var key string //将key与value放在for循环外避免重复定义
   var value int
   for i := 0; i < 20; i++ {
      key = fmt.Sprintf("第%02d", i) // %02d : 不足两位的整数用0补足，超出或等于两位的整数正常输出
      value = rand.Intn(20)         //生产0~19的整数
      s2[key] = value
   }
   //5.调用printOrderly函数
   printOrderly(s2)
}

//将map中的元素按序打印
func printOrderly(s2 map[string]int) {
   //1.初始化一个容量为s2长度的切片
   s3 := make([]string, 0, len(s2))
   //2.遍历s2，将key存入切片中
   for k := range s2 {
      s3 = append(s3, k)
   }
   //3.为切片中的key排序
   sort.Strings(s3)
   //4.输出
   for _, v := range s3 {
      fmt.Println(v, s2[v])
   }
}
```





## type关键字

自定义类型或者别名或者结构体



### 自定义类型

#### 基于内置的基本类型定义

语法：**`type typeName 数据类型`**

```go
//自定义类型:编译后仍然有效
type myInt int
var a myInt = 100
fmt.Printf("%T\n", a) //main.myInt
```

> 输出类型为`main.myInt`,表示该类型是在main包下定义的





#### 类型别名

类型别名是`Go1.9`版本添加的新功能

语法：**`type typeName = 数据类型`**

```go
//类型别名:仅在编译时有效，例如字符类型rune是int32的别名
type yourInt = int
var b yourInt = 100
fmt.Printf("%T\n", b) //int
```

> 输出类型为`int`,表示`yourInt`别名在编译后已经无效了





#### 结构体

使用`type`和`struct`关键字来定义结构体，**结构体为值类型**

语法：

```go
type 类型名 struct {
    字段名 字段类型
    字段名 字段类型
    …
}
```

- 类型名：标识自定义结构体的名称，在同一个包内不能重复。
- 字段名：表示结构体字段名。结构体中的字段名必须唯一。
- 字段类型：表示结构体字段的具体类型。

示例：自定义Person类型

```go
type Person struct {
	name  string
	age   int
	sex   string
	hobby []string
}
```

> 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）



##### 结构体的实例化

- 基本实例化

  ```go
  var p Person
  //未赋值时结构体中的属性都为对应的零值
  fmt.Println(p) //{ 0  []}
  fmt.Printf("p的类型为: %T\n", p)	//p的类型为: main.Person
  p.name = "郑晓颖"
  p.age = 12
  p.sex = "男"
  p.hobby = []string{"打篮球", "打足球"}
  fmt.Println(p)	//{郑晓颖 12 男 [打篮球 打足球]}
  ```

- 使用**new**来进行实例化

  ```go
  p1 := new(Person)             		//返回结构体的地址，p1为指针类型
  fmt.Printf("%v\n",p1)						//&{ 0  []},各项属性取值亦为各自数据类型的零值
  fmt.Printf("p1的类型为：%T\n", p1) 	 //p1的类型为：*main.Person
  p1.age = 12
  p1.hobby = []string{"打球"}
  p1.name = "郑晓颖"
  p1.sex = "男"
  fmt.Println(p1) //&{郑晓颖 12 男 [打球]}
  ```

- 使用匿名结构体来进行实例化

  ```go
  var boy struct {
  name string
  age  int
  }
  fmt.Printf("boy的类型为: %T\n", boy)	//boy的类型为: struct { name string; age int }
  fmt.Printf("%v\n",boy)				  //{ 0}
  p2.age = 12
  p2.hobby = []string{"打球"}
  p2.name = "郑晓颖"
  p2.sex = "男"
  fmt.Println(p2) //&{郑晓颖 12 男 [打球]}
  ```

- 使用&取地址符来进行实例化，相当于new操作

  ```go
  p2 := &Person{}
  fmt.Printf("%v\n",p2)			  //&{ 0  []}
  fmt.Printf("p2的类型为：%T\n", p2) //p2的类型为：*main.Person
  p2.age = 12
  p2.hobby = []string{"打球"}
  p2.name = "郑晓颖"
  p2.sex = "男"
  fmt.Println(p2) //&{郑晓颖 12 男 [打球]}
  ```

- 使用键值对来进行实例化

  ```go
  p3 := Person{
      age:   16,
      name:  "p3",
      hobby: []string{"打篮球"},
      sex:   "男",
  }
  fmt.Printf("%v\n",p3)			  //{p3 16 男 [打篮球]}
  fmt.Printf("p3的类型为：%T\n", p3) //p3的类型为：main.Person
  ```

- 当某些字段不需要赋值时，可以不写

  ```go
  p4 := Person{
      age:   16,
  }
  fmt.Printf("%#v\n",p4)			  //{ 16  []}
  fmt.Printf("p4的类型为：%T\n", p4) //p4的类型为：main.Person
  ```

- 不写字段名

  ```go
  p4 := Person{
      "p4",
      16,
      "男",
      []string{"打篮球"},
  }
  fmt.Printf("%v\n",p4)			  //{p4 16 男 [打篮球]}
  fmt.Printf("p4的类型为：%T\n", p4) //p4的类型为：main.Person
  ```

  使用这种格式初始化时，需要注意：

  1. 必须初始化结构体的所有字段。
  2. 初始值的填充顺序必须与字段在结构体中的声明顺序一致。
  3. 该方式不能和键值初始化方式混用。

> 无论使用哪种实例化方式，只要结构体的属性未被赋值，则其默认值为各自数据类型的零值

> 假设p为指针类型，**`p.age`** 在底层实际是**`(*p).age`**，这是Go实现的语法糖



##### 结构体构造函数

```go
type Person struct {
	name string
	age int
	sex string
	hobbys []string
}

func newPerson(name, sex string, age int, hobbys []string) *Person {
	return &Person {
		name: name,
		age: age,
		sex: sex,
		hobbys: hobbys,
	}
}

func main () {
	person := newPerson("郑晓颖","男", 22, []string{"游泳", "跑步"})
	fmt.Printf("%#v\n", person)
}
```



##### 结构体面试题

```go
type student struct {
	name string
	age  int
}

func main() {
	m := make(map[string]*student)
	stus := []student{
		{name: "小王子", age: 18},
		{name: "娜扎", age: 23},
		{name: "大王八", age: 9000},
	}

	for _, stu := range stus {
		m[stu.name] = &stu
	}
	for k, v := range m {
		fmt.Println(k, "=>", v.name)
	}
    //	娜扎 => 大王八
    //	大王八 => 大王八
    //	小王子 => 大王八
}
```



##### 结构体的匿名字段

> 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段

```go
type Person struct {
	int
	string
}

func main() {
	p1 := &Person {
		22,
		"郑晓颖",
	}
	fmt.Printf("%#v\n",p1)
	fmt.Printf("p1.int:%d,p1.string:%s\n",p1.int,p1.string)
}
```

> 匿名字段会采用字段数据类型作为字段名，结构体要求字段名唯一，因此每一种数据类型只能有一个字段



##### 结构体嵌套

> 一个结构体中可以嵌套包含另一个结构体或结构体指针

```go
type Address struct {
	province string
	city	 string
}

//普通嵌套结构体
type Person struct {
	name string
	age  int
	address Address
}

//嵌套匿名结构体
type Person1 struct {
	name string
	age int
	Address
}

func main() {
	person := &Person {
		name: "郑晓颖",
		age:   22,
		address:Address {
			province: "广东",
			city:     "珠海",
		},
	}
	fmt.Printf("%v\n",person.address.province)	//无法使用`person.province`调用province，会报错

	//嵌套匿名结构体
	person1 := &Person1 {
		//同一层次的字段实例化时，要么全部匿名，要么全部不匿名，否则会报错
		"郑晓颖",
		22,
		Address {
			province: "广东",
			city:     "珠海",
		},
	}
	fmt.Printf("%v\n", person1.Address.province)
    fmt.Printf("%v\n", person1.city)	//匿名字段可以省略
}
```

> **对于非匿名的结构体字段，不可以省略结构体名**
>
> **对于匿名的结构体字段，则可以省略结构体名**
>
> **同一层次的字段实例化时，要么全部匿名，要么全部不匿名，否则会报错**



##### 嵌套结构体的字段名冲突

```go
type Address struct {
	province string
	city string
	createTime string
}

type Email struct {
	accout string
	createTime string
}

type User struct {
	name string
	gender string
	//两个有重名字段的匿名结构体
	Address
	Email
}

func main() {
	user := &User {
		name: "郑晓颖",
		gender: "男",
		Address: Address{
			province: "广东省",
			city: "珠海市",
			createTime: "2021-11-08",
		},
		Email: Email{
			accout: "1625778735",
			createTime: "2022-11-08",
		},
	}

	fmt.Printf("user.createTime: %v",user.createTime)	//结构体有字段命名冲突的匿名结构体，不可以省略匿名结构体名
	fmt.Printf("user.Address.createTime: %v\n",user.Address.createTime)
	fmt.Printf("user.Email.createTime: %v\n",user.Email.createTime)


}
```

> **对于匿名的结构体字段，则可以省略结构体名，但当该结构体的字段与其他匿名结构体字段冲突时，不应该省略结构体名，不然会报错**



##### 结构体继承

```go
type Animal struct {
	name string
}

func (animal *Animal) move() {
	fmt.Printf("%s 会动\n",animal.name)
}

type Dog struct {
	feet int
	//通过嵌套匿名结构体实现继承
	*Animal
}

func (dog * Dog) wang() {
	fmt.Printf("%s会汪汪汪~\n", dog.name)
}

func main() {
	dog := &Dog {
		feet: 8,
		Animal: &Animal {
			name: "狗",
		},
	}

	dog.wang()
	dog.move()
}
```

> **可以通过嵌套匿名结构体来实现继承**



##### 结构体json序列化与反序列化

```go
import (
    //json的包名
	"encoding/json"	
	"fmt"
)

type Student struct {
	Id int
	Name string
	Gender string
}

type Class struct {
	Name string
	Students []*Student
}

func main() {
	class := &Class {
		Name: "3年一班",
		Students: make([]*Student, 0, 200),
	}

	for i:= 0; i < 10; i++ {
		stu := &Student {
			Id: i,
			Name: fmt.Sprintf("%02d",i),
			Gender: "男",
		}
		class.Students = append(class.Students,stu)
	}

	//JSON序列化
	data, err := json.Marshal(class)
	if err != nil {
		fmt.Println("序列化失败!")
		return
	}
	s := fmt.Sprintf("%s",data)
	fmt.Println(string(data))

	//反序列化
	class1 := &Class{}
	err = json.Unmarshal([]byte(s), class1)
	if err != nil {
		fmt.Println("反序列化失败!")
		return
	}
	fmt.Printf("%#v",class1)
}
```

> **使用json.Marshal和json.Unmarshal分别进行序列化和反序列化**



##### 通过结构体Tag自定义json字段名

```go
type Student struct {
	//指定id作为json键值即key
	ID int 	`json:"id"`
	//key默认与字段名一致
	Name string
	//私有字段无法被json读取，因为私有属性在相同包内被访问
	gender string
}

func main() {
	stu := &Student{
		ID:     3,
		Name:   "郑晓颖",
		gender: "男",
	}
	data, err := json.Marshal(stu)
	if err != nil {
		fmt.Printf("序列化错误,错误原因为: %v\n",err)
		return
	}
	fmt.Printf("%s\n",data)
}
```

> **通过在字段后边加反引号``来指定json key值**
>
> **key值默认与字段名一致**
>
> **私有字段无法被json读取，因为私有属性在相同包内被访问**



##### 使用接口接收结构体

- 方法接收者为值类型

```go
type Animal interface {
	eat()
}

type Dog struct {}

func (d Dog) eat() {
	fmt.Println("接收者类型为值类型")
}

func main() {
	var d Dog
	var animal1 Animal = d
    var animal2 Animal = &d
	animal1.eat()
    animal2.eat()
}
```

> **当结构体实现的方法接收者为值类型时，接口既能接受指针类型也能接受值类型**

- 方法接收者为指针类型

```go
type Animal interface {
	eat()
}

type Dog struct {}

func (d *Dog) eat() {
	fmt.Println("接收者类型为指针类型")
}

func main() {
	var d Dog
	var animal1 Animal = d	//会报错
	var animal2 Animal = &d
	animal1.eat()
	animal2.eat()
}
```

> **当结构体实现的方法接收者为指针类型时，接口只能接受指针类型**

| 方法接收者类型\结构体变量类型 | 值类型 | 指针类型 |
| ----------------------------- | ------ | -------- |
| 指针类型                      | NO     | YES      |
| 值类型                        | YES    | YES      |

> **表格中的YES与NO表示接口能否接收该类型的变量**



## 方法

Go语言中的`方法（Method）`是一种作用于特定类型变量的函数，类似于java中的成员函数

语法：

```go
func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

**接受者类型指定此方法属于哪种类型，只有该类型能调用此方法**，方法与Go里函数的区别是，函数不属于任何类型，方法属于特定的类型。

- 接收类型为值类型的方法

  ```go
  func (p Person) GetAge() int {
     return p.age
  }
  ```

- 接收类型为指针类型的方法

  ```go
  func (p *Person) SetAge(age int) {
     p.age = age
  }
  ```

> struct结构体类型是值类型，**值类型想要在方法中修改其属性必须要用指针类型的方法**，否则修改的只是结构体变量的副本而已

### 什么时候应该使用指针类型接收者

1. 需要修改接收者中的值
2. 接收者是拷贝代价比较大的大对象
3. 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。



对于非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法，可以使用 type myInt int将int声明为本地类型从而使用方法

```go
type MyInt int

func (m MyInt) Hello() {
   fmt.Println("Hello")
}
```



示例：

```go
//结构体Person
//struct是值类型
type Person struct {
	name  string
	age   int
	sex   string
	hobby []string
}

//Person构造函数，返回的不是指针
func NewPerson(name, sex string, age int, hobby []string) Person {
	return Person{
		name:  name,
		age:   age,
		sex:   sex,
		hobby: hobby,
	}
}

//接收者为值类型
func (p Person) GetAge() int {
	return p.age
}

//接收者为指针类型
//结构体为值类型，想要在方法中修改其属性并且保存就需要用到指针类型
func (p *Person) SetAge(age int) {
	p.age = age
}

func main() {
	p1 := NewPerson("郑晓颖", "男", 18, []string{"打篮球"})
	fmt.Println(p1.GetAge()) //如果p1是值类型，则正常调用，如果p1是指针类型，则相当于(*p1).GetAge()
	p1.SetAge(20)            //如果p1是值类型，则相当于(&p1).SetAge()，所以也能修改自身属性,如果p1是指针类型，则正常调用
	fmt.Println(p1)          //这即是go语言的语法糖
}
```

| 实例类型\方法接收者类型 | 值类型 | 指针类型 |
| ----------------------- | ------ | -------- |
| 值类型                  | OK     | OK       |
| 指针类型                | OK     | OK       |

> **值类型的示例调用接收者为指针类型的方法也能修改自身属性**



## 接口

- 在Go语言中接口`interface`是一种类型
- 接口是一组方法`method`的集合，当一个对象实现了这组方法`method`,我们就称该对象实现了该接口，这就是鸭式编程`duck-type programming`的体现
- `duck-type programming`: 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子



### 接口定义

```go
type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
```

- **如果接口类型只包含一个方法，那么这个接口的名字应该以er结尾，如果接口定义了多个方法，则其名字需要与其行为关联**

例子：

```go
type Shape interface{
	Draw()
}
```



### 接口的实现

当一个对象实现了这组方法`method`,我们就称该对象实现了该接口，这里使用`Circle`和`Triangle`实现了接口`Shape`,**既可以使用值类型方法实现接口，也可以使用指针类型方法实现接口**

```go
//形状
type Shape interface {
	Draw()
}

//圆形
type Circle struct {}

//实现了接口Shape
func (c Circle) Draw() {
	fmt.Println("这里是circle圆形")
}

//三角形
type Triangle struct {}

func (t *Triangle) Draw() {
	fmt.Println("这里是triangle三角形")
}
```

可以使用占位符来确保对象实现了接口,当该语句编译不报错时，便说明Circle实现了该接口

```go
var _ Shape = Circle{}
```

接口的方法不一定要由一个类型实现，也可由子类型实现，**子类型要匿名**

```go
// WashingMachine 洗衣机
type WashingMachine interface {
	wash()
	dry()
}

// 甩干器
type dryer struct{}

// 实现WashingMachine接口的dry()方法
func (d dryer) dry() {
	fmt.Println("甩一甩")
}

// 海尔洗衣机
type haier struct {
	dryer //嵌入甩干器,注意这里要用匿名，不然无法实现接口WashingMachine
}

// 实现WashingMachine接口的wash()方法
func (h haier) wash() {
	fmt.Println("洗刷刷")
}
```



### 使用接口接收对象

当一个对象实现一个接口后，我们就可以用该接口来接收实现了该接口的对象，根据实现方式的不同，接收方式也不同

- 只要有一个方法使用指针类型实现时,需要传递指针类型给接口接收

  ```go
  var shape Shape
  //shape = Triangle{} 会报错，需要传递指针给接口接收
  shape = &Triangle{}
  shape.Draw()
  ```

- 当全部方法都是用值类型实现时，既可以传递值类型给接口，也可以传递指针类型给接口

  ```go
  var shape Shape
  shape = Circle{}	//shape = &Circle{}	这里既可传递指针也可以传递值
  shape.Draw()
  ```



### 接口嵌套

接口与接口间可以通过嵌套创造出新的接口。

```go
// Sayer 接口
type Sayer interface {
	say()
}

// Mover 接口
type Mover interface {
	move()
}

// 接口嵌套
type animal interface {
	Sayer
	Mover
}
```

嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：

```go
type cat struct {
	name string
}

func (c cat) say() {
	fmt.Println("喵喵喵")
}

func (c cat) move() {
	fmt.Println("猫会动")
}

func main() {
	var x animal
	x = cat{name: "花花"}
	x.move()
	x.say()
}
```



### 空接口

空接口是没有定义任何方法的接口，因此任何类型都实现了空接口，所以空接口可以接收任何类型的变量

```go
//接口也能在函数内定义
type Null interface{}
var null Null
null = "李小龙"
fmt.Println(null)
```



### 类型断言

空接口可以接收任何类型的变量，那么怎么从一个空接口确定它具体是什么类型什么值呢？这时候就要用到**类型断言**了

想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：

```go
x.(T)
```

其中：

- x：表示类型为`interface{}`的变量
- T：表示断言`x`可能是的类型。

该语法返回两个参数，第一个参数是`x`转化为`T`类型后的变量，第二个值是一个布尔值，若为`true`则表示断言成功，为`false`则表示断言失败。

举个例子：

```go
func main() {
	var x interface{}
	x = "Hello 沙河"
	v, ok := x.(string)
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println("类型断言失败")
	}
}
```

上面的示例中如果要断言多次就需要写多个`if`判断，这个时候我们可以使用`switch`语句来实现：

```go
func justifyType(x interface{}) {
	switch v := x.(type) {
	case string:
		fmt.Printf("x is a string，value is %v\n", v)
	case int:
		fmt.Printf("x is a int is %v\n", v)
	case bool:
		fmt.Printf("x is a bool is %v\n", v)
	default:
		fmt.Println("unsupport type！")
	}
}
```

因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。

关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。



## init函数

程序里的所有init方法都会在main函数启动前被调用



## goroutine

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。



### goroutine的使用

```go
func Hello() {
   fmt.Println("Hello World")
}
//直接在函数前加go即可开启goroutine
go Hello()
```



### GOMAXPROCS

Go运行时的调度器使用`GOMAXPROCS`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。

Go语言中可以通过`runtime.GOMAXPROCS()`函数设置当前程序并发时占用的CPU逻辑核心数。

Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。

```go
func GOMAXPROCS(n int) int	//设置当前程序并发时占用的CPU逻辑核心数
```

```go
func NumCPU() int	//获取当前程序所能使用的最大CPU核心数，在程序开始执行时便已确定
```

```go
runtime.GOMAXPROCS(runtime.NumCPU())
```



### sync.WaitGroup

在代码中生硬的使用`time.Sleep`肯定是不合适的，Go语言中可以使用`sync.WaitGroup`来实现并发任务的同步。 `sync.WaitGroup`有以下几个方法：

|             方法名              |        功能         |
| :-----------------------------: | :-----------------: |
| (wg * WaitGroup) Add(delta int) |    计数器+delta     |
|     (wg *WaitGroup) Done()      |      计数器-1       |
|     (wg *WaitGroup) Wait()      | 阻塞直到计数器变为0 |

`sync.WaitGroup`内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。

我们利用`sync.WaitGroup`将上面的代码优化一下：

```go
var wg sync.WaitGroup

func hello() {
	defer wg.Done()
	fmt.Println("Hello Goroutine!")
}
func main() {
	wg.Add(1)
	go hello() // 启动另外一个goroutine去执行hello函数
	fmt.Println("main goroutine done!")
	wg.Wait()
}
```

需要注意`sync.WaitGroup`是一个结构体，传递的时候要传递指针。



## channel

- 虽然可以使用共享内存在多个`goroutine`进行数据交换，但是共享内存在不同的`goroutine`中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。
- Go语言提倡**通过通信共享内存**而不是**通过共享内存而实现通信**。`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。
- **`channel`是一种类型，一种`引用类型`**



### channel的定义

channel是引用类型，它的空值为`nil`，所以需要初始化后才能使用

```go
var 变量 chan 元素类型
```

```go
var ch1 chan string	//能传递string类型的通道
var ch2 chan int	//能传递int类型的通道
fmt.Println(ch1 == nil)    //true
fmt.Println(ch2 == nil)    //true
```



### channel的初始化

channel的初始化需要使用`make()`来实现

```
make(chan 元素类型, [缓冲大小])	
```

```go
ch1 = make(chan string)	//初始化一个无缓冲的通道
ch2 = make(chan int, 2)	//初始化一个缓冲为2的通道
```

- 通道初始化,第一个为通道类型，第二个为通道缓冲大小，**不填缓冲则无缓冲,如果无缓冲，当前线程会阻塞直到通道中数据被接收**



### channel的使用

通道有发送、接收、关闭三种操作，其中发送和接收都使用`<-`符号

- 发送操作

  ```go
  ch1 <- "郑晓颖"	//把一个字符串发送到ch1中
  ```

- 接收操作

  ```go
  x := <- ch1	//使用x接收ch1中的第一个数据
  <- ch1	//匿名接收ch1中的第一个数据
  ```

- 关闭操作

  ```go
  close(ch1)	
  ```

  关于关闭通道需要注意的事情是，只有在通知接收方goroutine**所有的数据都发送完毕**的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

  关闭后的通道有以下特点：

  - 对一个关闭的通道再发送值就会导致panic。

  - 对一个关闭的通道进行接收会一直获取值直到通道为空,也就是说关闭通道后仍然可以从通道中获取里面存在的数据。

  - 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。

  - 关闭一个已经关闭的通道会导致panic。

示例：

```go
var wg sync.WaitGroup

//往通道发送数据
func send(ch chan string) {
    defer wg.Done()
	//使用cap函数能获取通道的容量
	//使用len函数能获取通道中的数据数量
	for i := 0; i < cap(ch) - len(ch); i++ {
		ch <- fmt.Sprintf("第%d条数据", i)
	}
	close(ch)
}

//接收通道中的数据
func receive(ch chan string) {
    defer wg.Done()
	//使用for range遍历得到通道中的数据，当读完后会自动退出
	for val := range ch {
		fmt.Println(val)
	}
}

func main() {
	ch := make(chan string, 2)
	//开启两个线程实现数据发送与接收
	wg.Add(2)
	go send(ch)
	go receive(ch)
	//等待线程执行完成
	wg.Wait()
}
```



### 单向通道

单向通道通常在函数参数声明时使用，例子如下

```go
func test(ch chan <- int)	//只接收chan int类型的通道，在test函数中只能进行发送操作，否则会报错
func test(ch <- chan int)	//只接收chan int类型的通道，在test函数中只能进行接收操作，否则会报错
```



### 通道总结

`channel`常见的异常总结，如下图：![channel异常总结](https://www.liwenzhou.com/images/Go/concurrence/channel01.png)



案例：

```go
/**
	使用并发模拟击球比赛
 */

var wg sync.WaitGroup

//会在main函数被调用前执行
func init() {
	rand.Seed(time.Now().UnixNano())
}

func player(name string, ch chan int) {
	defer wg.Done()

	for {
		ball, ok := <- ch	//通道关闭则返回false
		//通道被关闭的话就表示我们赢了
		if !ok {
			fmt.Printf("%s 赢了\n", name)
			break
		}

		//随机判断接球是否成功
		i := rand.Intn(100)
		//偶数则接球成功
		if i != 99 {
			fmt.Printf("%s Hit %d\n", name, ball)
			ball++
			ch <- ball
		} else {	//接球失败
			fmt.Printf("%s 接球失败\n", name)
			//主动关闭通道表示输了
			close(ch)
			break
		}
	}
}

func main() {
	ch := make(chan int)
	wg.Add(2)
	go player("郑晓颖", ch)
	go player("郑兵颖", ch)
	ch <- 1


	wg.Wait()
}
```

```go
/**
使用并发模拟接力比赛
*/

var wg sync.WaitGroup

func main() {
	wg.Add(1)
	ch := make(chan int)
	go Runner(ch)

	//比赛开始
	ch <- 1
	wg.Wait()
}

func Runner(ch chan int) {
	defer wg.Done()
	runner := <- ch
	fmt.Printf("运动员%d号接棒\n", runner)
	fmt.Printf("运动员%d号跑起来了\n", runner)
	if runner < 4 {
		newRunner := runner + 1
		fmt.Printf("运动员%d号已就位\n", newRunner)
		wg.Add(1)
		go Runner(ch)

		fmt.Printf("运动员%d号开始传棒\n", runner)
		ch <- newRunner
	} else {
		fmt.Printf("运动员%d号冲过终点\n", runner)
		fmt.Println("比赛结束！")
		close(ch)
	}


}
```

