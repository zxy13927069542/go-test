## Go环境变量配置

- 删掉环境变量中有关`Go`的配置，比如`GOROOT`,`GOPATH`,注意别把`GOLAND`的配置删了

- 安装Go

  - 安装go之后会自动帮你配置好环境变量，其中`GOROOT`配置在系统变量的`Path`中，如图所示:

  ![image-20211127192441453](Go开发笔记.assets\image-20211127192441453-16381659904831.png)

  - `GOPATH`配置在用户变量的`GOPATH`和`Path`中,如图所示:

    ![image-20211127192319304](Go开发笔记.assets\image-20211127192319304-16381659904832.png)

![image-20211127192352675](Go开发笔记.assets\image-20211127192352675-16381659904843.png)

- 修改环境变量,虽然默认的也能用，但是不符合我们的使用习惯，所以我们可以修改环境变量来满足个人习惯

  - 修改`GOPATH`，需要修改的有两个点，第一个点是用户环境变量中的`GOPATH`，第二个点是用户环境变量中的`Path`,按下图修改:

  ![image-20211127192550268](Go开发笔记.assets\image-20211127192550268-16381659904844.png)

  ![image-20211127192704102](Go开发笔记.assets\image-20211127192704102-16381662013837.png)

  - 修改`GOROOT`，同样需要修改两个点，第一点是在系统变量中新增`GOROOT`，第二是修改系统变量中的`Path`，按下图修改：

    ![image-20211127193407759](Go开发笔记.assets\image-20211127193407759-16381659904845.png)

    ![image-20211127193454709](Go开发笔记.assets\image-20211127193454709-16381659904846.png)

- 打开`cmd`,输入`go env`，查看环境是否配置正确



## goland

### 代码自动补全

#### 后缀补全(关键字：.val)

![image-20211220141520017](Go开发笔记.assets/image-20211220141520017.png)





## Git



### 安装

### 设置用户名和邮箱

```go
git config --global user.name	"zxy"								//设置用户名
git config --global user.email	"zhengxiaoying666@gmail.com"		//设置邮箱
```



### 创建仓库

在项目路径下执行命令,命令执行后会在项目路径下生成`.git`目录,该目录为隐藏目录

```
git init
```



### 将文件提交到仓库暂存区

```
git add [file1] [file2] ...		//添加一个或多个文件到暂存区
git add [dir]					//添加指定目录到暂存区,包括子目录
git add .						//添加当前目录下所有文件到暂存区
git add all						//提交全部修改
```



### 将暂存区内的修改提交到本地仓库

```
git commit -m "第一次提交"		
```

> `-m`后面输入的是本次提交的说明





### 查看仓库状态

```
git status
```



### 查看提交历史

```
git log 		//--pretty=oneline 只显示版本号和提交消息
```



### 版本表示

- `HEAD`表示当前版本,`HEAD^`表示上个版本,`HEAD^^`表示上上个版本,`HEAD~50`表示上50个版本

- 版本号，版本号可以独特表示某一版本

### 版本回退

基于上述的版本表示，可以使用`git reset`来进行版本回退，从而回退到某个版本

```
git reset --hard HEAD^		//回退到上个版本
git reset --hard 5a97cde	//回退到版本号为5a97cde的版本
```

版本回退图解：

![image-20211127203437617](Go开发笔记.assets\image-20211127203437617.png)

Git在内部有个指向当前版本的`HEAD`指针，当你回退版本的时候，仅仅只是修改`HEAD`的指向而已

从最新的版本`append GPL`回退到`add distributed`后又想回到`append GPL`怎么处理？

```
git reflog	//git reflog用来记录你的每一次命令
```

![image-20211127204302082](Go开发笔记.assets\image-20211127204302082.png)

前面的几位数字就是版本号,我们可以使用该版本号来回退版本



### 撤销修改

```
git checkout -- file1	//让这个文件回到最近一次git commit或git add时的状态
git reset HEAD <file>	//可以把暂存区的修改撤销掉（unstage）
git rm --cache <file> [-r [dir]]	//撤销add
```

小结：

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，则需要版本回退，不过前提是没有推送到远程库。



### 生成SSH key

```
ssh-keygen -t rsa -C "zhengxiaoying666@gmail.com"
```

此命令会在用户主目录下的`.ssh`目录下生成`id_rsa`和`id_rsa_pub`两个文件，如果已有这两个文件则不用执行此命令

- 在github创建ssh，将公钥`id_rsa_pub`的内容复制到github的`SSH Keys`上

- 创建github仓库

- 将本地仓库与github仓库关联

  ```
  git remote add origin git@github.com:zxy13927069542/book.git
  ```

- 将本地仓库推送到远程仓库

  ```
  git push <远程主机名> <本地分支名>:<远程分支名>
  git push -u origin master	//会在远端创建master分支
  git push origin :master		//表示删除远端分支master
  ```

- 断开与远程仓库的连接

  ```
  git remote rm origin
  ```





### 克隆远程仓库

```
git clone git@github.com:zxy13927069542/book.git
```

你也许还注意到，GitHub给出的地址不止一个，还可以用`https://github.com/michaelliao/gitskills.git`这样的地址。实际上，Git支持多种协议，默认的`git://`使用ssh，但也可以使用`https`等其他协议。

使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。



### 从远程仓库拉取

```
git pull <remote> <branch>
```



![image-20211209212841768](Go开发笔记.assets/image-20211209212841768.png)



### Git无法正常显示中文

![image-20211127200558753](Go开发笔记.assets\image-20211127200558753.png)

```
git config --global core.quotepath false
```

输入此命令后即可正常显示

![image-20211127200732300](Go开发笔记.assets\image-20211127200732300.png)



### git操作步骤

改完代码，先commit到本地，再pull远程仓库的修改，合并修改后再push，在这个合并的过程中，可能会出现

```go
Merge remote-tracking branch 'origin/dev' into dev
```

![image-20211217094924741](Go开发笔记.assets/image-20211217094924741.png)

出现了两条commit消息，为了消除这条消息，同时又保留修改，我们可以进行`Reset dev to this commit`操作



### git代理设置

```go
git config --global http.proxy 127.0.0.1:7890	//设置http代理
git config --global https.proxy 127.0.0.1:7890	//设置https代理
git config --global --unset http.proxy			//取消http代理
git config --global --unset https.proxy			//取消https代理
```



## 常用命令

#### go build

`go build test.go`会在当前目录下生成`test.exe`可执行文件



#### go clean

在指定目录下执行`go clean`，可以删除编译生成的可执行文件1



#### go run

`go run`不会在运行目录下生成任何文件，可执行文件被放在临时文件中被执行



#### go fmt

`go fmt 文件名或包名`可以格式化代码



#### go env

- 设置GOPROXY

  ```go
  go env -w GOPROXY=https://goproxy.io,direct
  ```

  



#### godoc



##### 下载godoc

`godoc`在go1.13后需要自己下载

```go
//启用go module
go env -w GO111MODULE=on

//配置 GOPROXY 选一个就行
//阿里云
go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct # 
//官方
go env -w GOPROXY=https://goproxy.io,direct

//下载go doc
go get golang.org/x/tools/cmd/godoc
```



##### 使用godoc

使用`godoc -http=:6060`命令即可开启文档服务器，访问`http://localhost:6060`即可看到



#### go mod init 项目名



#### go mod tidy 

根据`go.mod`文件下载依赖，需要配置终端代理

终端代理设置

```go
vim ~/.bashrc
// 在bashrc中新增两行
export http_proxy=http://10.7.3.67:8080
export https_proxy=http://10.7.3.67:8080

source ~/.bashrc
// 查看代理设置
env |grep -i proxy

// 取消代理
unset http_proxy
unset https_proxy
```



### 包

- 每个包都在相同的目录，不能把多个包放在相同的目录，也不能把同一个包的文件拆到多个不同的目录，同一目录下的所有go代码文件都必须同属一个包
- 包名全小写，惯例为目录名
- main包中的main函数为程序入口，生成的可执行文件名为main包所在目录



#### 命名导入

```go
import calc "go-test/ying/package"

func main() {
	calc.Reduce(3,4)
}
```



#### 匿名导入

```go
import _ "go-test/ying/package"
```

> **当想导入一个不在代码中使用的包时，可以使用空白标识符`_`来匿名导包从而不报错**



### Delve

- ```
  Goland Debug报错:
  	Version of Delve is too old for this version of Go (maximum supported version 1.12, suppress this error with --check-go-version=false)
  	即Delve版本过旧或者压根没有Deve
  ```

  - 解决措施：下载一个高版本或新的Delve,并在goland中配置其路径

    1. ```
       go get -u github.com/go-delve/delve/cmd/dlv	//下载dlv到本地
       ```

    2. 用everything搜索delve.exe找到其路径，并克隆到Go安装路径的bin目录下

    3. 打开 `Hele->Edit Customer Properties`,若提示文件不存在，点击创建。然后在新加一行 

       ```
       dlv.path=Go的安装路径/bin/dlv.exe
       ```

        重启就可以了



## iota

```go
//每遇到一个const关键字，iota初始化为0，每新增一行变量声明iota加一
const (
   A1 = iota 	//0
   A2   		//1
   A3  			//2
)
fmt.Println(A1, A2, A3)
```



## 整型

|  类型  |                             描述                             |
| :----: | :----------------------------------------------------------: |
| uint8  |                  无符号 8位整型 (0 到 255)                   |
| uint16 |                 无符号 16位整型 (0 到 65535)                 |
| uint32 |              无符号 32位整型 (0 到 4294967295)               |
| uint64 |         无符号 64位整型 (0 到 18446744073709551615)          |
|  int8  |                 有符号 8位整型 (-128 到 127)                 |
| int16  |              有符号 16位整型 (-32768 到 32767)               |
| int32  |         有符号 32位整型 (-2147483648 到 2147483647)          |
| int64  | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |

> `uint8`就是`byte`
>
> ```
> type byte = uint8
> ```



### 特殊整型

|  类型   |                          描述                          |
| :-----: | :----------------------------------------------------: |
|  uint   | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
|   int   |  32位操作系统上就是`int32`，64位操作系统上就是`int64`  |
| uintptr |              无符号整型，用于存放一个指针              |



## float



### 保留有效数字

```go
//
//  RetainValidNumber
//  @Description: 保留有效数字
//  @param f
//  @param n 要保留的位数
//  @return string
//
func RetainValidNumber(f float64, n int) string {
   //获取整数
   trunc := int(math.Trunc(f))

   //计算要保留的小数位数
   length := len(strconv.Itoa(trunc))

   //四舍五入保留有效数字
   var rtValue float64
   if n <= length {
      return strconv.Itoa(trunc)[:n]
   } else {
      rtValue, _ = decimal.NewFromFloat(f).Round(int32(n - length)).Float64()

      //float64 -> string
      return strconv.FormatFloat(rtValue, 'f', n-length, 64)
   }
}
```



## 数组

- 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是**数组大小不可变化**
- 数组为值类型



### 数组定义

```go
var s1 [3]int
var s2 [4]int
fmt.Printf("s1的类型为%T\n", s1) //s1的类型为[3]int
fmt.Printf("s2的类型为%T\n", s2) //s2的类型为[4]int
fmt.Printf("%v\n", s1)	//[0 0 0]
fmt.Printf("%v\n", s2)	//[0 0 0 0]
```

> **数组的长度为类型的一部分，长度不同，即使是同一数据类型的数组类型也不同**



### 数组初始化

```go
//数组初始化

//第一种
var s3 [3]int = [3]int{1, 1, 1}
fmt.Println(s3)

//第二种
s4 := [3]int{1, 1, 1}
fmt.Println(s4)

//第三种
s5 := [...]int{1, 1, 1}
fmt.Printf("s5的类型为%T\n值为%v\n", s5, s5) //类型为[3]int

//与第三种区分，这种初始化方式是切片，不是数组
s6 := []int{1, 1, 1}
fmt.Printf("s6的类型为%T\n值为%v\n", s6, s6) //类型为[]int,切片，长度可变

//第四种
s7 := [5]int{0: 1, 4: 3}               //根据索引来进行初始化
fmt.Printf("s7的类型为%T\n值为%v\n", s7, s7) //[1 0 0 0 3]
```



### 数据遍历

- 普通for循环

  ```go
  s8 := [...]int{3, 4, 5, 6}
  //普通for循环
  for i := 0; i < len(s8); i++ {	
      fmt.Println(s8[i])
  }
  ```

  > 可以使用内置函数`len`来获取数组长度

- for range循环

  ```go
  s8 := [...]int{3, 4, 5, 6}
  //for range循环
  for i1, v1 := range s8 {
      fmt.Printf("\n索引为%v的值为%v\n", i1, v1)
  }
  ```

  > for index, value := range s8



### 二维数组

```go
arr := [3][2]string{
    {"数学", "语文"},
    {"篮球", "足球"},
    {"画画", "唱歌"},
}
fmt.Printf("%v\n",arr)	//[[数学 语文] [篮球 足球] [画画 唱歌]]

//使用普通for循环遍历
for i := 0; i < len(arr); i++ {
    for y := 0; y < len(arr[i]); y++ {
        fmt.Println(arr[i][y])
    }
}

//使用for range遍历
for _, v := range arr {
    for _, v1 := range v {
        fmt.Println(v1)
    }
}
```



### 数组的复制

因为数组是值类型，所以数组可以像一个值一样赋值给类型相同的数组

```go
arr1 := [3]string {"李宁", "塞班", "鸿星尔克"}
var arr2 [3]string
arr2 = arr1
fmt.Printf("%p\n",&arr1)	//0xc00007c390
fmt.Printf("%p\n",&arr2)	//0xc00007c3c0
arr2[0] = "白雨"
fmt.Println(arr1)	//[李宁 塞班 鸿星尔克]
fmt.Println(arr2)	//[白雨 塞班 鸿星尔克]
```

> **使用%p可以输出变量的地址，可以看到arr1与arr2的变量地址不一样**
>
> **修改arr2后，arr1并没有改变**



### 在函数间传递数组

**根据内存和性能来看，在函数间传递数组是一件开销很大的操作。在函数间传递变量时，总是以值的方式传递的，所以对于数组来说，一般是使用指针来进行数组的传递**

```go
var arr1 [300]int
func foo(arr *[300]int)
foo(&arr1)
```



## 切片

- 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

- 切片是一个**引用类型**，它的内部结构包含`地址`、`长度`和`容量`
- 切片的类型不像数组一样与长度挂钩，例如`var arr []int`,则切片的类型为`[]int`



### 切片定义

```go
//切片为引用类型，未初始化的切片为nil，相当于null
var s2 []int
fmt.Println(s2)	//[]
fmt.Println(s2 == nil)	//true
fmt.Printf("s2的长度为:%d,容量为:%d\n", len(s2), cap(s2)) //s2的长度为:0,容量为:0
s2[0] = 1	//未初始化的切片无法赋值，会报错
var s3 []int
fmt.Println(s2 == s3)	//会报错
```

> **对于引用类型来说，其零值就是nil，另外，切片之间不支持直接比较**
>
> **可以使用内置函数`len`来获取切片的元素个数**
>
> **可以使用内置函数`cap`来获取切片的容量，超过容量切片便会自动扩容**
>
> **未初始化的切片无法赋值，会报错**



### 切片的初始化

- 直接初始化

  ```go
  //定义一个切片
  s1 := []int{1, 2}
  //修改切片
  s1[0] = 0
  fmt.Println(s1)
  fmt.Printf("s1的长度为:%d,容量为:%d\n", len(s1), cap(s1)) //s1的长度为:2,容量为:2
  fmt.Println(s1 == nil)	//false
  
  //初始化过的切片不为nil，即使长度与容量均为0
  s6 := []int{}
  fmt.Printf("s6的长度为:%d,容量为:%d\n", len(s6), cap(s6)) //s6的长度为:0,容量为:0
  fmt.Println(s6 == nil) //false
  ```

  > **直接初始化的切片长度与容量默认相等**
  >
  > **初始化过的切片不为nil，即使长度与容量均为0**

- 使用make初始化

  `make函数`可以指定切片的长度，容量

  ```go
  s5 := make([]int, 5, 10) //s5的类型为[]int，长度为5，容量为10
  fmt.Printf("值为:%v\n",s5)	//[0 0 0 0 0]
  ```

- 由数组得到切片，会将数组作为切片的底层数组，两者会互相影响

  ```go
  //由数组得到切片
  s3 := [...]int{3, 3, 3}
  s4 := s3[:]
  s4[0] = 1 //数组相应的值也会发生变化
  fmt.Println(s3, s4)
  ```

- 由切片得到切片,**两个切片指向同一个底层数组，因此也会互相影响**

  ```go
  s1 := []int{3,3,3,3}
  s2 := s1[:2]
  fmt.Printf("s1的指针: %p, s1的值: %v\n", &s1, s1)	//s1的指针: 0xc000004078, s1的值: [3 3 3 3]
  fmt.Printf("s2的指针: %p, s2的值: %v\n", &s2, s2)	//s2的指针: 0xc000004090, s2的值: [3 3]
  //修改s1
  s1[0] = 1
  fmt.Printf("s1的值: %v\n", s1)	//s1的值: [1 3 3 3]
  fmt.Printf("s2的值: %v\n", s2)	//s2的值: [1 3]
  ```

  

### 切片表达式

```go
s4 := s3[a:b]	//从数组中截取(a,b]的段落作为切片的值
s4 := s3[a:]	//截取从下标a开始的数组段落
s4 := s3[:b]	//从头截取数组段落直到数组下标b
s4 := s3[:]		//截取数组的全部
```



### 切片的长度

切片长度是指当前切片中有多少个元素，可以用`len(s1)`获取



### 切片的容量

切片的容量指当前切片最多能存储多少个元素，当容量不足时会自动扩容，容量可以用`cap(s1)`获取



### 切片的本质

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

举个例子，现在有一个数组`a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}`，切片`s1 := a[:5]`，相应示意图如下。![slice_01](Go开发笔记.assets/slice_01.png)切片`s2 := a[3:6]`，相应示意图如下：![slice_02](Go开发笔记.assets/slice_02.png)



### 切片判空

判断切片是否为空，应该使用`len(s1) == 0`来判断，而不是`s1 == nil`



### 切片的赋值拷贝

切片为引用类型，将切片直接赋值给另一个切片会导致两个切片指向同一个底层数组，修改其中一个切片会导致另一个切片的改变

```go
s1 := make([]int, 3, 9)
fmt.Println("修改前s1:",s1)	//修改前s1: [0 0 0]
s2 := s1
fmt.Println("修改前s2:",s2)	//修改前s2: [0 0 0]
//修改s2
s2[0] = 1
fmt.Println("修改后s1:",s1)	//修改后s1: [1 0 0]
fmt.Println("修改后s2:",s2)	//修改后s2: [1 0 0]
```

使用内置函数`copy()`进行切片拷贝

```go
copy(destSlice, srcSlice []T)
```

```go
s1 := []int{3,3,3}
//需要s2容量足够才能copy，copy并不会进行扩容操作
s2 := make([]int, 3, 3)
fmt.Printf("copy前s1: %v\n",s1)
copy(s2, s1)
fmt.Printf("copy后s1: %v，s1的地址：%p\n",s1, &s1)
fmt.Printf("copy后s2: %v, s2的地址: %p\n",s2, &s2)
```



### 切片遍历

切片遍历与数组遍历一致，都可以用普通for循环遍历和for range 遍历，**这里有一点要注意，for range会创建每个元素的副本，所以如果切片元素为值类型的话，修改是无效的。**



### append

切片可以使用`append()`函数来新增元素，在使用`append()`时如果切片容量不足会自动扩容，在使用`append()`会往底层数组新增元素，如果底层数组的容量足够，则直接新增，无需扩容，如果底层数组容量不足，此时的底层数组就会更换，扩容到一个容量更大的底层数组去。

```
func append(slice []Type, elems ...Type) []Type
```

```go
//使用append函数扩容,扩容后容量依照策略进行增加
s9 := make([]int, 3, 3)
fmt.Printf("len:%d,cap:%d,value:%v\n", len(s9), cap(s9), s9)	//len:3,cap:3,value:[0 0 0]
s9 = append(s9, 3, 3)
fmt.Printf("len:%d,cap:%d,value:%v\n", len(s9), cap(s9), s9)	//len:5,cap:6,value:[0 0 0 3 3]
```

> 切片的扩容策略通常为2倍

- 新增一个元素

  ```go
  s1 = append(s1, 3)
  ```

- 新增多个元素

  ```
  s1 = append(s1, 3, 3)
  ```

- 使用切片来新增元素

  ```
  arr := []int{3, 3, 3}
  s1 = append(s1, arr...)	//...表示把切片拆分成一个一个的元素
  ```

  > 无法使用数组来新增元素



使用切片扩容后原切片仍然存在

```go
s1 := make([]int, 3, 3)
fmt.Printf("扩容前s1: %v\n", s1)	//扩容前s1: [0 0 0]
s2 := append(s1, 3)
fmt.Printf("扩容后s1: %v\n", s1)	//扩容后s1: [0 0 0]
fmt.Printf("扩容后s2: %v\n", s2)	//扩容后s2: [0 0 0 3]

s3 := append(s1, s2...)
fmt.Printf("再一次扩容后s1: %v\n", s1)	//再一次扩容后s1: [0 0 0]
fmt.Printf("再一次扩容后s2: %v\n", s2)	//再一次扩容后s2: [0 0 0 3]
fmt.Printf("再一次扩容后s3: %v\n", s3)	//再一次扩容后s3: [0 0 0 0 0 0 3]
```



### 从切片中删除元素

Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：

```go
func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
```

总结一下就是：要从切片a中删除索引为`index`的元素，操作方法是`a = append(a[:index], a[index+1:]...)`



## map

- Go语言提供的映射关系容器为`map`，其内部使用哈希表`hash`实现，相当于java的`HashMap`
- map是**引用类型**



### map的定义

map为引用类型，**如果不经初始化分配内存则为`nil`,此时往里存数据会报错**

```go
var m1 map[int]string
fmt.Println(m1 == nil)	//true
map[0] = "AAA"	//会报错
```



### map的初始化

map定义之后还需要分配内存空间来进行初始化，类似于java中的new操作，所以**使用make来分配内存空间进行初始化**

```go
s1 := make(map[int]string, 10) //第一个参数为map类型，第二个参数为map容量，超出容量会动态扩容
s1[0] = "AAA"	//初始化之后可以往map中存储元素

//在定义时就填充元素
m := map[int]string {
    3 : "郑晓颖",
    10 : "郑晓燕",
    001 : "郑兵颖",	//相当于 1 : "郑兵颖"
}
```



### 判断某个键是否存在

```go
m := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
    3 : "郑速贤",
    4 : "郑周珊",
}
//判断key为1的键值对是否存在，并用val接收值，用exit接收存在结果，存在则为true，不存在则为false
val, exit := m[1]
if exit {
    fmt.Println(val)	//郑晓颖
}
```



### map的遍历

由于map是基于`hash`实现的，其内部存储元素是无序的，因此无法用普通`for`循环遍历，只能用`for range`遍历

```go
s1 := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
}
//1.map的遍历
//2.map中元素无序，无法用普通for循环遍历，需要使用for range遍历
for key, value := range s1 {
    fmt.Println(key, value)
    //直接修改range返回的key和value是无效的，返回的key和value只是副本
    value = "郑周珊"
    //这种修改才有效
    s1[key] = "郑速贤"
}
```

- 与切片一致，`for range`返回的`key`和`value`是副本，直接修改反映不到map中



### 使用delete删除键值对

删除map中的键值对需要使用内置函数`delete()`来删除

```go
func delete(m map[Type]Type1, key Type)
```

```go
s1 := map[int]string {
    1 : "郑晓颖",
    2 : "郑兵颖",
}
//内建函数delete按照指定的键将元素从映射中删除。若m为nil或无此元素，delete不进行操作。
delete(s1, 1)
fmt.Println(s1)	//map[2:郑兵颖]
```



### 按照指定顺序遍历map

```go
/**
生成随机数的value，并按照key的顺序打印键值对
 */
func main() {
   //1.测试printOrderly函数
   //2.初始化随机数种子
   rand.Seed(time.Now().UnixNano())
   //3.初始化map
   s2 := make(map[string]int, 20)
   //4.往map中填充元素
   var key string //将key与value放在for循环外避免重复定义
   var value int
   for i := 0; i < 20; i++ {
      key = fmt.Sprintf("第%02d", i) // %02d : 不足两位的整数用0补足，超出或等于两位的整数正常输出
      value = rand.Intn(20)         //生产0~19的整数
      s2[key] = value
   }
   //5.调用printOrderly函数
   printOrderly(s2)
}

//将map中的元素按序打印
func printOrderly(s2 map[string]int) {
   //1.初始化一个容量为s2长度的切片
   s3 := make([]string, 0, len(s2))
   //2.遍历s2，将key存入切片中
   for k := range s2 {
      s3 = append(s3, k)
   }
   //3.为切片中的key排序
   sort.Strings(s3)
   //4.输出
   for _, v := range s3 {
      fmt.Println(v, s2[v])
   }
}
```





## type关键字

自定义类型或者别名或者结构体



### 自定义类型

#### 基于内置的基本类型定义

语法：**`type typeName 数据类型`**

```go
//自定义类型:编译后仍然有效
type myInt int
var a myInt = 100
fmt.Printf("%T\n", a) //main.myInt
```

> 输出类型为`main.myInt`,表示该类型是在main包下定义的





#### 类型别名

类型别名是`Go1.9`版本添加的新功能

语法：**`type typeName = 数据类型`**

```go
//类型别名:仅在编译时有效，例如字符类型rune是int32的别名
type yourInt = int
var b yourInt = 100
fmt.Printf("%T\n", b) //int
```

> 输出类型为`int`,表示`yourInt`别名在编译后已经无效了





#### 结构体

使用`type`和`struct`关键字来定义结构体，**结构体为值类型**

语法：

```go
type 类型名 struct {
    字段名 字段类型
    字段名 字段类型
    …
}
```

- 类型名：标识自定义结构体的名称，在同一个包内不能重复。
- 字段名：表示结构体字段名。结构体中的字段名必须唯一。
- 字段类型：表示结构体字段的具体类型。

示例：自定义Person类型

```go
type Person struct {
	name  string
	age   int
	sex   string
	hobby []string
}
```

> 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）



##### 结构体的实例化

- 基本实例化

  ```go
  var p Person
  //未赋值时结构体中的属性都为对应的零值
  fmt.Println(p) //{ 0  []}
  fmt.Printf("p的类型为: %T\n", p)	//p的类型为: main.Person
  p.name = "郑晓颖"
  p.age = 12
  p.sex = "男"
  p.hobby = []string{"打篮球", "打足球"}
  fmt.Println(p)	//{郑晓颖 12 男 [打篮球 打足球]}
  ```

- 使用**new**来进行实例化

  ```go
  p1 := new(Person)             		//返回结构体的地址，p1为指针类型
  fmt.Printf("%v\n",p1)						//&{ 0  []},各项属性取值亦为各自数据类型的零值
  fmt.Printf("p1的类型为：%T\n", p1) 	 //p1的类型为：*main.Person
  p1.age = 12
  p1.hobby = []string{"打球"}
  p1.name = "郑晓颖"
  p1.sex = "男"
  fmt.Println(p1) //&{郑晓颖 12 男 [打球]}
  ```

- 使用匿名结构体来进行实例化

  ```go
  var user struct{Name string; Age int}
  user.Name = "小王子"
  user.Age = 18
  fmt.Printf("%#v\n", user)
  ```

- 使用&取地址符来进行实例化，相当于new操作

  ```go
  p2 := &Person{}
  fmt.Printf("%v\n",p2)			  //&{ 0  []}
  fmt.Printf("p2的类型为：%T\n", p2) //p2的类型为：*main.Person
  p2.age = 12
  p2.hobby = []string{"打球"}
  p2.name = "郑晓颖"
  p2.sex = "男"
  fmt.Println(p2) //&{郑晓颖 12 男 [打球]}
  ```

- 使用键值对来进行实例化

  ```go
  p3 := Person{
      age:   16,
      name:  "p3",
      hobby: []string{"打篮球"},
      sex:   "男",
  }
  fmt.Printf("%v\n",p3)			  //{p3 16 男 [打篮球]}
  fmt.Printf("p3的类型为：%T\n", p3) //p3的类型为：main.Person
  ```

- 当某些字段不需要赋值时，可以不写

  ```go
  p4 := Person{
      age:   16,
  }
  fmt.Printf("%#v\n",p4)			  //{ 16  []}
  fmt.Printf("p4的类型为：%T\n", p4) //p4的类型为：main.Person
  ```

- 不写字段名

  ```go
  p4 := Person{
      "p4",
      16,
      "男",
      []string{"打篮球"},
  }
  fmt.Printf("%v\n",p4)			  //{p4 16 男 [打篮球]}
  fmt.Printf("p4的类型为：%T\n", p4) //p4的类型为：main.Person
  ```

  使用这种格式初始化时，需要注意：

  1. 必须初始化结构体的所有字段。
  2. 初始值的填充顺序必须与字段在结构体中的声明顺序一致。
  3. 该方式不能和键值初始化方式混用。

> 无论使用哪种实例化方式，只要结构体的属性未被赋值，则其默认值为各自数据类型的零值

> 假设p为指针类型，**`p.age`** 在底层实际是**`(*p).age`**，这是Go实现的语法糖



##### 结构体构造函数

```go
type Person struct {
	name string
	age int
	sex string
	hobbys []string
}

func newPerson(name, sex string, age int, hobbys []string) *Person {
	return &Person {
		name: name,
		age: age,
		sex: sex,
		hobbys: hobbys,
	}
}

func main () {
	person := newPerson("郑晓颖","男", 22, []string{"游泳", "跑步"})
	fmt.Printf("%#v\n", person)
}
```



##### 结构体面试题

```go
type student struct {
	name string
	age  int
}

func main() {
	m := make(map[string]*student)
	stus := []student{
		{name: "小王子", age: 18},
		{name: "娜扎", age: 23},
		{name: "大王八", age: 9000},
	}

	for _, stu := range stus {
		m[stu.name] = &stu
	}
	for k, v := range m {
		fmt.Println(k, "=>", v.name)
	}
    //	娜扎 => 大王八
    //	大王八 => 大王八
    //	小王子 => 大王八
}
```



##### 结构体的匿名字段

> 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段

```go
type Person struct {
	int
	string
}

func main() {
	p1 := &Person {
		22,
		"郑晓颖",
	}
	fmt.Printf("%#v\n",p1)
	fmt.Printf("p1.int:%d,p1.string:%s\n",p1.int,p1.string)
}
```

> 匿名字段会采用字段数据类型作为字段名，结构体要求字段名唯一，因此每一种数据类型只能有一个字段



##### 结构体嵌套

> 一个结构体中可以嵌套包含另一个结构体或结构体指针

```go
type Address struct {
	province string
	city	 string
}

//普通嵌套结构体
type Person struct {
	name string
	age  int
	address Address
}

//嵌套匿名结构体
type Person1 struct {
	name string
	age int
	Address
}

func main() {
	person := &Person {
		name: "郑晓颖",
		age:   22,
		address:Address {
			province: "广东",
			city:     "珠海",
		},
	}
	fmt.Printf("%v\n",person.address.province)	//无法使用`person.province`调用province，会报错

	//嵌套匿名结构体
	person1 := &Person1 {
		//同一层次的字段实例化时，要么全部匿名，要么全部不匿名，否则会报错
		"郑晓颖",
		22,
		Address {
			province: "广东",
			city:     "珠海",
		},
	}
	fmt.Printf("%v\n", person1.Address.province)
    fmt.Printf("%v\n", person1.city)	//匿名字段可以省略
}
```

> **对于非匿名的结构体字段，不可以省略结构体名**
>
> **对于匿名的结构体字段，则可以省略结构体名**
>
> **同一层次的字段实例化时，要么全部匿名，要么全部不匿名，否则会报错**



##### 嵌套结构体的字段名冲突

```go
type Address struct {
	province string
	city string
	createTime string
}

type Email struct {
	accout string
	createTime string
}

type User struct {
	name string
	gender string
	//两个有重名字段的匿名结构体
	Address
	Email
}

func main() {
	user := &User {
		name: "郑晓颖",
		gender: "男",
		Address: Address{
			province: "广东省",
			city: "珠海市",
			createTime: "2021-11-08",
		},
		Email: Email{
			accout: "1625778735",
			createTime: "2022-11-08",
		},
	}

	fmt.Printf("user.createTime: %v",user.createTime)	//结构体有字段命名冲突的匿名结构体，不可以省略匿名结构体名
	fmt.Printf("user.Address.createTime: %v\n",user.Address.createTime)
	fmt.Printf("user.Email.createTime: %v\n",user.Email.createTime)


}
```

> **对于匿名的结构体字段，则可以省略结构体名，但当该结构体的字段与其他匿名结构体字段冲突时，不应该省略结构体名，不然会报错**



##### 结构体继承

```go
type Animal struct {
	name string
}

func (animal *Animal) move() {
	fmt.Printf("%s 会动\n",animal.name)
}

type Dog struct {
	feet int
	//通过嵌套匿名结构体实现继承
	*Animal
}

func (dog * Dog) wang() {
	fmt.Printf("%s会汪汪汪~\n", dog.name)
}

func main() {
	dog := &Dog {
		feet: 8,
		Animal: &Animal {
			name: "狗",
		},
	}

	dog.wang()
	dog.move()
}
```

> **可以通过嵌套匿名结构体来实现继承**



##### 结构体json序列化与反序列化

```go
import (
    //json的包名
	"encoding/json"	
	"fmt"
)

type Student struct {
	Id int
	Name string
	Gender string
}

type Class struct {
	Name string
	Students []*Student
}

func main() {
	class := &Class {
		Name: "3年一班",
		Students: make([]*Student, 0, 200),
	}

	for i:= 0; i < 10; i++ {
		stu := &Student {
			Id: i,
			Name: fmt.Sprintf("%02d",i),
			Gender: "男",
		}
		class.Students = append(class.Students,stu)
	}

	//JSON序列化
	data, err := json.Marshal(class)
	if err != nil {
		fmt.Println("序列化失败!")
		return
	}
	s := fmt.Sprintf("%s",data)
	fmt.Println(string(data))

	//反序列化
	class1 := &Class{}
	err = json.Unmarshal([]byte(s), class1)
	if err != nil {
		fmt.Println("反序列化失败!")
		return
	}
	fmt.Printf("%#v",class1)
}
```

> **使用json.Marshal和json.Unmarshal分别进行序列化和反序列化**



##### 通过结构体Tag自定义json字段名

```go
type Student struct {
	//指定id作为json键值即key
	ID int 	`json:"id"`
	//key默认与字段名一致
	Name string
	//私有字段无法被json读取，因为私有属性在相同包内被访问
	gender string
}

func main() {
	stu := &Student{
		ID:     3,
		Name:   "郑晓颖",
		gender: "男",
	}
	data, err := json.Marshal(stu)
	if err != nil {
		fmt.Printf("序列化错误,错误原因为: %v\n",err)
		return
	}
	fmt.Printf("%s\n",data)
}
```

> **通过在字段后边加反引号``来指定json key值**
>
> **key值默认与字段名一致**
>
> **私有字段无法被json读取，因为私有属性在相同包内被访问**



##### 使用接口接收结构体

- 方法接收者为值类型

```go
type Animal interface {
	eat()
}

type Dog struct {}

func (d Dog) eat() {
	fmt.Println("接收者类型为值类型")
}

func main() {
	var d Dog
	var animal1 Animal = d
    var animal2 Animal = &d
	animal1.eat()
    animal2.eat()
}
```

> **当结构体实现的方法接收者为值类型时，接口既能接受指针类型也能接受值类型**

- 方法接收者为指针类型

```go
type Animal interface {
	eat()
}

type Dog struct {}

func (d *Dog) eat() {
	fmt.Println("接收者类型为指针类型")
}

func main() {
	var d Dog
	var animal1 Animal = d	//会报错
	var animal2 Animal = &d
	animal1.eat()
	animal2.eat()
}
```

> **当结构体实现的方法接收者为指针类型时，接口只能接受指针类型**

| 方法接收者类型\结构体变量类型 | 值类型 | 指针类型 |
| ----------------------------- | ------ | -------- |
| 指针类型                      | NO     | YES      |
| 值类型                        | YES    | YES      |

> **表格中的YES与NO表示接口能否接收该类型的变量**



### 结构体判空

```go
func DeepEqual(x, y interface{}) bool
```



## 方法

Go语言中的`方法（Method）`是一种作用于特定类型变量的函数，类似于java中的成员函数

语法：

```go
func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

**接受者类型指定此方法属于哪种类型，只有该类型能调用此方法**，方法与Go里函数的区别是，函数不属于任何类型，方法属于特定的类型。

- 接收类型为值类型的方法

  ```go
  func (p Person) GetAge() int {
     return p.age
  }
  ```

- 接收类型为指针类型的方法

  ```go
  func (p *Person) SetAge(age int) {
     p.age = age
  }
  ```

> struct结构体类型是值类型，**值类型想要在方法中修改其属性必须要用指针类型的方法**，否则修改的只是结构体变量的副本而已

### 什么时候应该使用指针类型接收者

1. 需要修改接收者中的值
2. 接收者是拷贝代价比较大的大对象
3. 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。



对于非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法，可以使用 type myInt int将int声明为本地类型从而使用方法

```go
type MyInt int

func (m MyInt) Hello() {
   fmt.Println("Hello")
}
```



示例：

```go
//结构体Person
//struct是值类型
type Person struct {
	name  string
	age   int
	sex   string
	hobby []string
}

//Person构造函数，返回的不是指针
func NewPerson(name, sex string, age int, hobby []string) Person {
	return Person{
		name:  name,
		age:   age,
		sex:   sex,
		hobby: hobby,
	}
}

//接收者为值类型
func (p Person) GetAge() int {
	return p.age
}

//接收者为指针类型
//结构体为值类型，想要在方法中修改其属性并且保存就需要用到指针类型
func (p *Person) SetAge(age int) {
	p.age = age
}

func main() {
	p1 := NewPerson("郑晓颖", "男", 18, []string{"打篮球"})
	fmt.Println(p1.GetAge()) //如果p1是值类型，则正常调用，如果p1是指针类型，则相当于(*p1).GetAge()
	p1.SetAge(20)            //如果p1是值类型，则相当于(&p1).SetAge()，所以也能修改自身属性,如果p1是指针类型，则正常调用
	fmt.Println(p1)          //这即是go语言的语法糖
}
```

| 实例类型\方法接收者类型 | 值类型 | 指针类型 |
| ----------------------- | ------ | -------- |
| 值类型                  | OK     | OK       |
| 指针类型                | OK     | OK       |

> **值类型的示例调用接收者为指针类型的方法也能修改自身属性**



## 接口

- 在Go语言中接口`interface`是一种类型
- 接口是一组方法`method`的集合，当一个对象实现了这组方法`method`,我们就称该对象实现了该接口，这就是鸭式编程`duck-type programming`的体现
- `duck-type programming`: 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子



### 接口定义

```go
type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
```

- **如果接口类型只包含一个方法，那么这个接口的名字应该以er结尾，如果接口定义了多个方法，则其名字需要与其行为关联**

例子：

```go
type Shape interface{
	Draw()
}
```



### 接口的实现

当一个对象实现了这组方法`method`,我们就称该对象实现了该接口，这里使用`Circle`和`Triangle`实现了接口`Shape`,**既可以使用值类型方法实现接口，也可以使用指针类型方法实现接口**

```go
//形状
type Shape interface {
	Draw()
}

//圆形
type Circle struct {}

//实现了接口Shape
func (c Circle) Draw() {
	fmt.Println("这里是circle圆形")
}

//三角形
type Triangle struct {}

func (t *Triangle) Draw() {
	fmt.Println("这里是triangle三角形")
}
```

可以使用占位符来确保对象实现了接口,当该语句编译不报错时，便说明Circle实现了该接口

```go
var _ Shape = Circle{}
```

接口的方法不一定要由一个类型实现，也可由子类型实现，**子类型要匿名**

```go
// WashingMachine 洗衣机
type WashingMachine interface {
	wash()
	dry()
}

// 甩干器
type dryer struct{}

// 实现WashingMachine接口的dry()方法
func (d dryer) dry() {
	fmt.Println("甩一甩")
}

// 海尔洗衣机
type haier struct {
	dryer //嵌入甩干器,注意这里要用匿名，不然无法实现接口WashingMachine
}

// 实现WashingMachine接口的wash()方法
func (h haier) wash() {
	fmt.Println("洗刷刷")
}
```



### 使用接口接收对象

当一个对象实现一个接口后，我们就可以用该接口来接收实现了该接口的对象，根据实现方式的不同，接收方式也不同

- 只要有一个方法使用指针类型实现时,需要传递指针类型给接口接收

  ```go
  var shape Shape
  //shape = Triangle{} 会报错，需要传递指针给接口接收
  shape = &Triangle{}
  shape.Draw()
  ```

- 当全部方法都是用值类型实现时，既可以传递值类型给接口，也可以传递指针类型给接口

  ```go
  var shape Shape
  shape = Circle{}	//shape = &Circle{}	这里既可传递指针也可以传递值
  shape.Draw()
  ```



### 接口嵌套

接口与接口间可以通过嵌套创造出新的接口。

```go
// Sayer 接口
type Sayer interface {
	say()
}

// Mover 接口
type Mover interface {
	move()
}

// 接口嵌套
type animal interface {
	Sayer
	Mover
}
```

嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：

```go
type cat struct {
	name string
}

func (c cat) say() {
	fmt.Println("喵喵喵")
}

func (c cat) move() {
	fmt.Println("猫会动")
}

func main() {
	var x animal
	x = cat{name: "花花"}
	x.move()
	x.say()
}
```



### 空接口

空接口是没有定义任何方法的接口，因此任何类型都实现了空接口，所以空接口可以接收任何类型的变量

```go
//接口也能在函数内定义
type Null interface{}
var null Null
null = "李小龙"
fmt.Println(null)
```



### 类型断言

空接口可以接收任何类型的变量，那么怎么从一个空接口确定它具体是什么类型什么值呢？这时候就要用到**类型断言**了

想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：

```go
x.(T)
```

其中：

- x：表示类型为`interface{}`的变量
- T：表示断言`x`可能是的类型。

该语法返回两个参数，第一个参数是`x`转化为`T`类型后的变量，第二个值是一个布尔值，若为`true`则表示断言成功，为`false`则表示断言失败。

举个例子：

```go
func main() {
	var x interface{}
	x = "Hello 沙河"
	v, ok := x.(string)
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println("类型断言失败")
	}
}
```

上面的示例中如果要断言多次就需要写多个`if`判断，这个时候我们可以使用`switch`语句来实现：

```go
func justifyType(x interface{}) {
	switch v := x.(type) {
	case string:
		fmt.Printf("x is a string，value is %v\n", v)
	case int:
		fmt.Printf("x is a int is %v\n", v)
	case bool:
		fmt.Printf("x is a bool is %v\n", v)
	default:
		fmt.Println("unsupport type！")
	}
}
```

因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。

关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。



## init函数

程序里的所有init方法都会在main函数启动前被调用



## goroutine

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。



### goroutine的使用

```go
func Hello() {
   fmt.Println("Hello World")
}
//直接在函数前加go即可开启goroutine
go Hello()
```



### GOMAXPROCS

Go运行时的调度器使用`GOMAXPROCS`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。

Go语言中可以通过`runtime.GOMAXPROCS()`函数设置当前程序并发时占用的CPU逻辑核心数。

Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。

```go
func GOMAXPROCS(n int) int	//设置当前程序并发时占用的CPU逻辑核心数
```

```go
func NumCPU() int	//获取当前程序所能使用的最大CPU核心数，在程序开始执行时便已确定
```

```go
runtime.GOMAXPROCS(runtime.NumCPU())
```



### sync.WaitGroup

在代码中生硬的使用`time.Sleep`肯定是不合适的，Go语言中可以使用`sync.WaitGroup`来实现并发任务的同步。 `sync.WaitGroup`有以下几个方法：

|             方法名              |        功能         |
| :-----------------------------: | :-----------------: |
| (wg * WaitGroup) Add(delta int) |    计数器+delta     |
|     (wg *WaitGroup) Done()      |      计数器-1       |
|     (wg *WaitGroup) Wait()      | 阻塞直到计数器变为0 |

`sync.WaitGroup`内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。

我们利用`sync.WaitGroup`将上面的代码优化一下：

```go
var wg sync.WaitGroup

func hello() {
	defer wg.Done()
	fmt.Println("Hello Goroutine!")
}
func main() {
	wg.Add(1)
	go hello() // 启动另外一个goroutine去执行hello函数
	fmt.Println("main goroutine done!")
	wg.Wait()
}
```

需要注意`sync.WaitGroup`是一个结构体，传递的时候要传递指针。



## channel

- 虽然可以使用共享内存在多个`goroutine`进行数据交换，但是共享内存在不同的`goroutine`中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。
- Go语言提倡**通过通信共享内存**而不是**通过共享内存而实现通信**。`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。
- **`channel`是一种类型，一种`引用类型`**



### channel的定义

channel是引用类型，它的空值为`nil`，所以需要初始化后才能使用

```go
var 变量 chan 元素类型
```

```go
var ch1 chan string	//能传递string类型的通道
var ch2 chan int	//能传递int类型的通道
fmt.Println(ch1 == nil)    //true
fmt.Println(ch2 == nil)    //true
```



### channel的初始化

channel的初始化需要使用`make()`来实现

```
make(chan 元素类型, [缓冲大小])	
```

```go
ch1 = make(chan string)	//初始化一个无缓冲的通道
ch2 = make(chan int, 2)	//初始化一个缓冲为2的通道
```

- 通道初始化,第一个为通道类型，第二个为通道缓冲大小，**不填缓冲则无缓冲,如果无缓冲，当前线程会阻塞直到通道中数据被接收**



### channel的使用

通道有发送、接收、关闭三种操作，其中发送和接收都使用`<-`符号

- 发送操作

  ```go
  ch1 <- "郑晓颖"	//把一个字符串发送到ch1中
  ```

- 接收操作

  ```go
  x := <- ch1	//使用x接收ch1中的第一个数据
  <- ch1	//匿名接收ch1中的第一个数据
  ```

- 关闭操作

  ```go
  close(ch1)	
  ```

  关于关闭通道需要注意的事情是，只有在通知接收方goroutine**所有的数据都发送完毕**的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

  关闭后的通道有以下特点：

  - 对一个关闭的通道再发送值就会导致panic。

  - 对一个关闭的通道进行接收会一直获取值直到通道为空,也就是说关闭通道后仍然可以从通道中获取里面存在的数据。

  - 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。

  - 关闭一个已经关闭的通道会导致panic。

示例：

```go
var wg sync.WaitGroup

//往通道发送数据
func send(ch chan string) {
    defer wg.Done()
	//使用cap函数能获取通道的容量
	//使用len函数能获取通道中的数据数量
	for i := 0; i < cap(ch) - len(ch); i++ {
		ch <- fmt.Sprintf("第%d条数据", i)
	}
	close(ch)
}

//接收通道中的数据
func receive(ch chan string) {
    defer wg.Done()
	//使用for range遍历得到通道中的数据，当读完后会自动退出
	for val := range ch {
		fmt.Println(val)
	}
}

func main() {
	ch := make(chan string, 2)
	//开启两个线程实现数据发送与接收
	wg.Add(2)
	go send(ch)
	go receive(ch)
	//等待线程执行完成
	wg.Wait()
}
```



### 单向通道

单向通道通常在函数参数声明时使用，例子如下

```go
func test(ch chan <- int)	//只接收chan int类型的通道，在test函数中只能进行发送操作，否则会报错
func test(ch <- chan int)	//只接收chan int类型的通道，在test函数中只能进行接收操作，否则会报错
```



### 通道总结

`channel`常见的异常总结，如下图：![channel异常总结](Go开发笔记.assets/channel01.png)



案例：

```go
/**
	使用并发模拟击球比赛
 */

var wg sync.WaitGroup

//会在main函数被调用前执行
func init() {
	rand.Seed(time.Now().UnixNano())
}

func player(name string, ch chan int) {
	defer wg.Done()

	for {
		ball, ok := <- ch	//通道关闭则返回false
		//通道被关闭的话就表示我们赢了
		if !ok {
			fmt.Printf("%s 赢了\n", name)
			break
		}

		//随机判断接球是否成功
		i := rand.Intn(100)
		//偶数则接球成功
		if i != 99 {
			fmt.Printf("%s Hit %d\n", name, ball)
			ball++
			ch <- ball
		} else {	//接球失败
			fmt.Printf("%s 接球失败\n", name)
			//主动关闭通道表示输了
			close(ch)
			break
		}
	}
}

func main() {
	ch := make(chan int)
	wg.Add(2)
	go player("郑晓颖", ch)
	go player("郑兵颖", ch)
	ch <- 1


	wg.Wait()
}
```

```go
/**
使用并发模拟接力比赛
*/

var wg sync.WaitGroup

func main() {
	wg.Add(1)
	ch := make(chan int)
	go Runner(ch)

	//比赛开始
	ch <- 1
	wg.Wait()
}

func Runner(ch chan int) {
	defer wg.Done()
	runner := <- ch
	fmt.Printf("运动员%d号接棒\n", runner)
	fmt.Printf("运动员%d号跑起来了\n", runner)
	if runner < 4 {
		newRunner := runner + 1
		fmt.Printf("运动员%d号已就位\n", newRunner)
		wg.Add(1)
		go Runner(ch)

		fmt.Printf("运动员%d号开始传棒\n", runner)
		ch <- newRunner
	} else {
		fmt.Printf("运动员%d号冲过终点\n", runner)
		fmt.Println("比赛结束！")
		close(ch)
	}


}
```



## fmt

### 占位符

#### 通用占位符

| 占位符 |             说明             |
| :----: | :--------------------------: |
|   %v   |         打印默认格式         |
|  %#v   |         打印详细信息         |
|   %T   |         打印值的类型         |
|  %+v   | 在默认格式的基础上显示字段名 |

```go
//
// TestPlaceholder
//  @Description: 测试占位符
//  @param t
//
func TestPlaceholder(t *testing.T) {
	//通用占位符
	type Person struct {
		Name string
		Age int
	}

	person := Person{
		Name: "郑晓颖",
		Age: 22,
	}

	fmt.Printf("person: %v\n", person)	//%v	person: {郑晓颖 22}
	fmt.Printf("person: %#v\n", person)	//%#v	person: main.Person{Name:"郑晓颖", Age:22}
	fmt.Printf("person: %+v\n", person)	//%+v	person: {Name:郑晓颖 Age:22}
}
```

> **从输出结果上看，显然`%+v`更符合我们的习惯**





#### 布尔

| 占位符 |    说明     |
| :----: | :---------: |
|   %t   | true或false |

```go
//布尔占位符
isTrue := true
fmt.Printf("isTrue: %t\n", isTrue)	//%t	isTrue: true
```



#### 整型

| 占位符 |                             说明                             |
| :----: | :----------------------------------------------------------: |
|   %b   |                         表示为二进制                         |
|   %c   |                    该值对应的unicode码值                     |
|   %d   |                         表示为十进制                         |
|   %o   |                         表示为八进制                         |
|   %x   |                   表示为十六进制，使用a-f                    |
|   %X   |                   表示为十六进制，使用A-F                    |
|   %U   |          表示为Unicode格式：U+1234，等价于”U+%04X”           |
|   %q   | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 |

```go
//整型占位符
i := 15
fmt.Printf("i: %b\n", i)   //%b   i: 1111
fmt.Printf("i: %c\n", i)   //%c   i: 
fmt.Printf("i: %d\n", i)   //%d   i: 15
fmt.Printf("i: %o\n", i)   //%o   i: 17
fmt.Printf("i: %x\n", i)   //%x   i: f
fmt.Printf("i: %X\n", i)   //%X   i: F
fmt.Printf("i: %U\n", i)   //%U   i: U+000F
fmt.Printf("i: %q\n", i)   //%q   i: '\x0f'
```



#### 浮点数

| 占位符 |                          说明                          |
| :----: | :----------------------------------------------------: |
|   %b   |   无小数部分、二进制指数的科学计数法，如-123456p-78    |
|   %e   |              科学计数法，如-1234.456e+78               |
|   %E   |              科学计数法，如-1234.456E+78               |
|   %f   |           有小数部分但无指数部分，如123.456            |
|   %F   |                        等价于%f                        |
|   %g   | 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
|   %G   | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） |

```GO
//浮点数
f := 12.34
fmt.Printf("f: %b\n", f)   //%b   f: 6946802425218990p-49
fmt.Printf("f: %e\n", f)   //%e   f: 1.234000e+01
fmt.Printf("f: %E\n", f)   //%E   f: 1.234000E+01
fmt.Printf("f: %f\n", f)   //%f   f: 12.340000
fmt.Printf("f: %F\n", f)   //%F   f: 12.340000
fmt.Printf("f: %g\n", f)   //%g   f: 12.34
fmt.Printf("f: %G\n", f)   //%G   f: 12.34
```



## os/signal

### type Signal

```
type Signal interface {
    String() string
    Signal() // 用来区分其他实现了Stringer接口的类型
}
```

**Signal代表一个操作系统信号**。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。

```
var (
    Interrupt Signal = syscall.SIGINT
    Kill      Signal = syscall.SIGKILL
)
```

仅有的肯定会被所有操作系统提供的信号，**Interrupt（中断信号）和Kill（强制退出信号）**。



### func Notify

```go
func Notify(c chan<- os.Signal, sig ...os.Signal)
```

```go
signal.Notify(r.interrupt, os.Interrupt)	//将中断信号转到目标通道
```

Notify函数让signal包将输入信号转发到c。如果没有列出要传递的信号，会将所有输入信号传递到c；否则只传递列出的输入信号。

signal包不会为了向c发送信息而阻塞（就是说如果发送时c阻塞了，signal包会直接放弃）：调用者应该保证c有足够的缓存空间可以跟上期望的信号频率。对使用单一信号用于通知的通道，缓存为1就足够了。



### func Stop

```
func Stop(c chan<- os.Signal)
```

Stop函数让signal包停止向c转发信号。它会**取消之前使用c调用的所有Notify的效果**。当Stop返回后，会保证c不再接收到任何信号。





## time

### time.Time

go语言中使用结构体类型time.Time来描述时间，具体使用如下：

```go
now := time.Now()   //获取当前时间
year := now.Year() //年份
month := now.Month()   //月份
day := now.Day()   //日期
weekday := now.Weekday()   //周几
hour := now.Hour() //小时
minute := now.Minute() //分钟
second := now.Second() //秒
```



### Unix时间戳

什么是Unix时间戳(Unix timestamp)： Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)， 是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的**总秒数**。 Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。

```go
now := time.Now()
unix := now.Unix()	//获取以秒为单位的时间戳
nano := now.UnixNano()	//获取以纳秒为单位的时间戳，如果超过int64的长度，结果不可知
fmt.Println(unix，nano)
```



### 时间戳转换成时间类型time.Time

函数`time.Unix()`可以实现从时间戳到`time.Time`的转换

```go
func Unix(sec int64, nsec int64) Time	//一般nsec为0
```

Unix创建一个本地时间，对应sec和nsec表示的Unix时间（从January 1, 1970 UTC至该时间的秒数和纳秒数）。

```go
now := time.Unix(time.Now().Unix(), 0)
fmt.Println(now)
```



### 时间间隔（时间单位）time.Duration

`time.Duration`是`time`中定义的自定义类型,其底层实现是`int64`

```go
type Duration int64
```

`time.Duration`可以用来表示一个时间单位

```go
const (
	Nanosecond  Duration = 1	//纳秒
	Microsecond          = 1000 * Nanosecond	//微秒
	Millisecond          = 1000 * Microsecond	//毫秒
	Second               = 1000 * Millisecond	//秒
	Minute               = 60 * Second	//分钟
	Hour                 = 60 * Minute	//小时
)
```



### 时间操作

#### Add

我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下：

```go
func (t Time) Add(d Duration) Time
```

举个例子，求一个小时之后的时间：

```go
func main() {
	now := time.Now()
	later := now.Add(time.Hour) // 当前时间加1小时后的时间
	fmt.Println(later)
}
```

#### Sub

求两个时间之间的差值：

```go
func (t Time) Sub(u Time) Duration
```

返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。

#### Equal

```go
func (t Time) Equal(u Time) bool
```

判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。

#### Before

```go
func (t Time) Before(u Time) bool
```

如果t代表的时间点在u之前，返回真；否则返回假。

#### After

```go
func (t Time) After(u Time) bool
```

如果t代表的时间点在u之后，返回真；否则返回假。



### 时间格式化

时间类型有一个自带的方法`Format`进行格式化，需要注意的是Go语言中格式化时间模板不是常见的`Y-m-d H:M:S`而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。也许这就是技术人员的浪漫吧。

补充：如果想格式化为12小时方式，需指定`PM`。

```go
//格式化Time
now := time.Now()
timeString := now.Format("2006-01-02 15:04:05")
fmt.Println(timeString)    //2021-11-16 09:19:16
```



解析格式化的时间字符串

第一个参数为格式化模板，第二个参数为想要解析的字符串，第三个参数为时区

```go
func ParseInLocation(layout, value string, loc *Location) (Time, error)
```

```go
//获取时区
location, err := time.LoadLocation("Asia/Shanghai")
if err != nil {
   fmt.Println(err)
   return
}
//从格式化字符串获取时间类型Time
Time, err := time.ParseInLocation("2006-01-02 15:04:05", "2021-11-16 09:19:16", location)
if err != nil {
   fmt.Println(err)
   return
}
fmt.Println(Time)  //2021-11-16 09:19:16 +0800 CST
```

案例：

```go
/**
获取任务耗时
*/

func main() {

   before := time.Now()
   print()
   After := time.Now()
   fmt.Println("任务耗时:", After.Sub(before).Seconds())
}

func print() {
   for i := 0; i < 10000000; i++ {
      fmt.Println(i)
   }
}
```





## strings

### Join

```go
func Join(a []string, sep string) string
```

将一系列字符串连接为一个字符串，之间用sep来分隔。

Example

```go
s := []string{"foo", "bar", "baz"}
fmt.Println(strings.Join(s, ", "))
```

Output:

```go
foo, bar, baz
```



### Index

```go
func Index(s, substr string) int
```

`strings.Index()`能获取指定字符子串的下标，如果字符子串不存在则返回`-1`, 这里有一个坑，就是返回的下标是底层的字节数组的下标，也就是说如果有一个字符占用多个字节，那就会出现期望下标跟实际返回下标不符的情况，这时可以测试该字符占用多少个字节，减去多占用的字节，即可得到正确的下标

```go
//°: 2个字节 ′: 三个字节 ″: 三个字节
s := `300°330′330″`

//验证这几个字符占用几个字节
//bytes := []byte(s)
//fmt.Println(bytes)

index0 := strings.Index(s, "°")
index1 := strings.Index(s, "′") - 1
index2 := strings.Index(s, "″") - 1 - 2
fmt.Println(index0, index1, index2)
```





## 文件操作



### 打开与关闭文件

```go
func Open(name string) (*File, error)

//Open的实现
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
```

根据路径`name`打开文件，返回文件的指针实例`*File`与错误`error`，实际调用了`OpenFile()`

```
func (f *File) Close() error
```

`*File`类型的方法，用来关闭文件

```go
file, err := os.Open("ErrorMsg.txt")
if err != nil {
   fmt.Println(err)
   return
}
file.Close()
```



### 读取文件

- 使用`file.Read()`读取文件

  ```go
  func (f *File) Read(b []byte) (n int, err error)
  ```

  > `n`:读取的字节数	`b`:用来存储缓存的字节切片
  >
  > 文件内部读取存在一个光标，指示当前读取到文件的哪里，如果**文件读完后再次进行读取则会报错，error = io.EOF**

  ```go
  file, err0 := os.Open("ErrorMsg.txt")
  if err0 != nil {
     fmt.Println(err0)
     return
  }
  //在此处使用defer能够比较清晰的体现文件答打开与关闭
  defer file.Close()
  //存储缓存的字节切片
  buff := make([]byte, 128)
  //存放文件全部内容的切片，无须初始化，append()会自动扩容，相当于初始化
  var contend []byte
  for {
     n, err1 := file.Read(buff)
     if err1 == io.EOF {
        fmt.Println("文件已经读完了")
        break
  
     }
     if err1 != nil {
        fmt.Println(err1)
        return
     }
     //将本次读取的内容存储到contend中，注意不能全部读取，buff[:n]表示只读取本次的内容，n为本次读取的字节数
     contend = append(contend, buff[:n]...)
  }
  fmt.Println(string(contend))
  ```

- 使用`bufio`读取文件

  ```go
  //打开文件
  file, err := os.Open("ErrorMsg.txt")
  if err != nil {
      fmt.Println("打开文件失败！错误原因为：", err)
      return
  }
  defer file.Close()
  //使用Bufio读取文件
  fileReader := bufio.NewReader(file)
  for {
      //读取'\n'之前的数据并包括'\n'
      line, err := fileReader.ReadString('\n')
      //如果遇到err == io.EOF则返回错误并返回在遇到错误前的数据
      //当读到最后一行会报err == io.EOF，需要在此打印line
      if err == io.EOF {
          if len(line) != 0 {
              fmt.Println(line)
          }
          fmt.Println("文件已经读完！")
          break
      }
      //当且仅当找不到截止符号时会err != nil
      if err != nil {
          fmt.Println("ERROR! 找不到截止符号！", err)
          return
      }
      //注意这里不要用Println,否则会多打换行符
      fmt.Print(line)
  }
  ```

- 使用`io/ioutil`包的`ReadFile()`读取文件

  ```go
  func ReadFile(filename string) ([]byte, error) {
     return os.ReadFile(filename)	
  }
  ```

  go 1.16开始，该方法相当于os.ReadFile()

  ```go
  contend, err := ioutil.ReadFile("./os/FileReading.go")
  if err != nil {
     fmt.Println("ERROR! 读取文件错误！错误为：", err)
     return
  }
  fmt.Println(string(contend))
  ```



### 文件写入操作

`os.OpenFile()`函数能够以指定模式打开文件，从而实现文件写入相关功能。

```go
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	...
}
```

其中：

`name`：要打开的文件名 `flag`：打开文件的模式。 模式有以下几种：

|     模式      |          含义          |
| :-----------: | :--------------------: |
| `os.O_WRONLY` |          只写          |
| `os.O_CREATE` | 当文件不存在时创建文件 |
| `os.O_RDONLY` |          只读          |
|  `os.O_RDWR`  |          读写          |
| `os.O_TRUNC`  |      清空文件内容      |
| `os.O_APPEND` |          追加          |

`perm`：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01，通常使用`0666`。

- 使用Write和WriteString写文件

```go
func main() {
    //注意这里perm要写0666，如果写777在文件存在的情况下会返回nil
	file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println("open file failed, err:", err)
		return
	}
	defer file.Close()
	str := "hello 沙河"
	file.Write([]byte(str))       //写入字节切片数据
	file.WriteString("hello 小王子") //直接写入字符串数据
}
```

- 使用bufio.NewWriter写文件

```go
func main() {
	file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println("open file failed, err:", err)
		return
	}
	defer file.Close()
	writer := bufio.NewWriter(file)
	for i := 0; i < 10; i++ {
		writer.WriteString("hello沙河\n") //将数据先写入缓存
	}
	writer.Flush() //将缓存中的内容写入文件
}
```

- 使用ioutil.WriteFile写文件

```go
/**
    ioutil的WriteFile()会直接覆盖文件内容
    相当于os.WriteFile(filename, data, perm)
    OpenFile(name, O_WRONLY|O_CREATE|O_TRUNC, perm)
*/
func main() {
	str := "hello 沙河"
	err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)
	if err != nil {
		fmt.Println("write file failed, err:", err)
		return
	}
}
```



案例：

```go
/**
	复制文件
 */
func CopyFile(src, des string) {
   srcFile, err := os.OpenFile(src, os.O_RDONLY, 777)
   if err != nil {
      fmt.Println("ERROR! 打开源文件失败！ 失败原因为：", err)
      return
   }
   //用于缓存源文件中的数据
   buff := make([]byte, 128)
   //var buff []byte  //无法使用nil的切片来接收
   var contend []byte
   //读取源文件
   for {
      n, err := srcFile.Read(buff)
      if err == io.EOF {
         break
      }
      if err != nil {
         fmt.Println("ERROR! 读取源文件失败！ 失败原因为：", err)
         return
      }
      contend = append(contend, buff[:n]...) //append()会自动扩容，所以可以用nil
   }
   srcFile.Close()

   //打开目标文件，如果目标文件不存在则创建，写文件为覆盖写
   //os.O_CREATE
   //注意这里perm要写0666，如果写777在文件存在的情况下会返回nil
   desFile, err := os.OpenFile(des, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
   //_, err = desFile.Write(contend)
   _, err = desFile.Write(contend)
   if err != nil {
      fmt.Println("ERROR! 写目标文件失败！ 失败原因为：", err)
      return
   }
   desFile.Close()

}
```



## builtin



### Panic()

```
func panic(v interface{})
```

内建函数panic停止当前Go程序的正常执行。当函数F调用panic时，F的正常执行就会立刻停止。F中defer的所有函数先入后出执行后，F返回给其调用者G。G如同F一样行动，层层返回，直到该Go程序中所有函数都按相反的顺序停止执行。之后，程序被终止，而错误情况会被报告，包括引发该恐慌的实参值，此终止序列称为恐慌过程。

```go
func main() {
   go func() {
      fmt.Println("func before")
      panic("bbb")	
      time.Sleep(time.Minute)
      fmt.Println("func after")
   }()
   fmt.Println("main before")	
   time.Sleep(time.Minute)
   fmt.Println("main after")
}
```

> 就算在goroutine中调用，main函数也会被终止

```go
main before
func before
panic: bbb	//panic执行后程序终止
goroutine 19 [running]:
main.main.func1()
        D:/WorkSpace/GoWorks/go-test/ying/test/test.go:11 +0xa5
created by main.main
        D:/WorkSpace/GoWorks/go-test/ying/test/test.go:9 +0x45

```





## log

Go中的`log`包实现了简单的日志服务

- `Print系列`(Print|Printf|Println）

  ```go
  log.Println("BBB")  //2021/11/17 16:57:00 BBB
  ```

  输出一条正常的日志

- `Fatal系列`（Fatal|Fatalf|Fatalln）

  ```go
  log.Fatal("AAA")    //2021/11/17 16:58:30 AAA
  ```

  Fatal系列函数会在写入日志信息后调用os.Exit(1)，相当于退出程序

- `Panic系列`（Panic|Panicf|Panicln）

  ```go
  log.Panicln("AAA")
  ```

  Panic系列函数会在写入日志信息后panic,即报错

  ![image-20211117170157653](Go开发笔记.assets\image-20211117170157653.png)



### 配置logger

#### 标准logger的配置

默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。`log`标准库中为我们提供了定制这些设置的方法。

`log`标准库中的`Flags`函数会返回标准logger的输出配置，而`SetFlags`函数用来设置标准logger的输出配置。

```go
func Flags() int
func SetFlags(flag int)
```

#### flag选项

`log`标准库提供了如下的flag选项，它们是一系列定义好的常量。

```go
const (
    // 控制输出日志信息的细节，不能控制输出的顺序和格式。
    // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    Ldate         = 1 << iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒级别的时间：01:23:23.123123（用于增强Ltime位）
    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23
    Lshortfile                    // 文件名+行号：d.go:23（会覆盖掉Llongfile）
    LUTC                          // 使用UTC时间
    LstdFlags     = Ldate | Ltime // 标准logger的初始值
)
```

下面我们在记录日志之前先设置一下标准logger的输出选项如下：

```go
func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println("这是一条很普通的日志。")
}
```

编译执行后得到的输出结果如下：

```go
2017/06/19 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。
```

#### 配置日志前缀

`log`标准库中还提供了关于日志信息前缀的两个方法：

```go
func Prefix() string
func SetPrefix(prefix string)
```

其中`Prefix`函数用来查看标准logger的输出前缀，`SetPrefix`函数用来设置输出前缀。

```go
func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println("这是一条很普通的日志。")
	log.SetPrefix("[小王子]")
	log.Println("这是一条很普通的日志。")
}
```

上面的代码输出如下：

```bash
[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。
```

这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。

#### 配置日志输出位置

```go
func SetOutput(w io.Writer)
```

`SetOutput`函数用来设置标准logger的输出目的地，默认是标准错误输出。

例如，下面的代码会把日志输出到同目录下的`xx.log`文件中。

```go
func main() {
	logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println("open log file failed, err:", err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println("这是一条很普通的日志。")
	log.SetPrefix("[小王子]")
	log.Println("这是一条很普通的日志。")
}
```

如果你要使用标准的logger，我们通常会把上面的配置操作写到`init`函数中。

```go
func init() {
	logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println("open log file failed, err:", err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
}
```

### 创建logger

`log`标准库中还提供了一个创建新logger对象的构造函数–`New`，支持我们创建自己的logger示例。`New`函数的签名如下：

```go
func New(out io.Writer, prefix string, flag int) *Logger
```

New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。

举个例子：

```go
func main() {
	logger := log.New(os.Stdout, "<New>", log.Lshortfile|log.Ldate|log.Ltime)
	logger.Println("这是自定义的logger记录的日志。")
}
```

将上面的代码编译执行之后，得到结果如下：

```bash
<New>2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。
```

### 总结

Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如[logrus](https://github.com/sirupsen/logrus)、[zap](https://github.com/uber-go/zap)等。



案例：

```go
/**
   定制四种不同级别的日志
 */
var (
   Trace  *log.Logger    //记录所有日志
   Info   *log.Logger    //记录普通日志
   Warning    *log.Logger    //记录注意日志
   Error  *log.Logger    //记录错误日志
)

/**
初始化日志
 */
func init() {
   //创建错误日志的输出文件
   file, err := os.OpenFile("errors.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
   if err != nil {
      log.Fatalln("创建错误日志文件失败", err)
   }

   //定制Trace等级日志
   Trace = log.New(ioutil.Discard, "[Trace] ", log.Ldate | log.Ltime | log.Llongfile)
   //定制Info等级日志
   Info = log.New(os.Stdout, "[Info] ", log.Ldate | log.Ltime | log.Llongfile)
   //定制Warning等级日志
   Warning = log.New(os.Stdout, "[Warning] ", log.Ldate | log.Ltime | log.Llongfile)
   //定制Error等级日志,将日志同时输出到file文件里和os.Stderr
   Error = log.New(io.MultiWriter(file, os.Stderr), "[Error] ", log.Ldate | log.Ltime | log.Llongfile)
}

func main() {
   Trace.Println("这里是Trace日志")
   Info.Println("这里是Info日志")
   Warning.Println("这里是Warning日志")
   Error.Println("这里是Error日志")
}
```





## encoding/json

### 解码

#### NewDecoder

```
func NewDecoder(r io.Reader) *Decoder
```

NewDecoder创建一个从r读取并解码json对象的*Decoder，解码器有自己的缓冲，并可能超前读取部分json数据。创建`*Decoder`后，可以调用方法`Decode()`将json数据解码到相应的结构体中。

#### Decoder

```
func (dec *Decoder) Decode(v interface{}) error
```

Decode从输入流读取下一个json编码值并保存在v指向的值里



#### Unmarshal

```
func Unmarshal(data []byte, v interface{}) error
```

Unmarshal函数用于解码字节切片`[]byte`类型的数据



案例：调用百度地图api，解码返回的json，并存储到对应的结构体

```go
/**
   顶层结点
 */
type Response struct {
   Status	int			`json: "status"`
   Message	string		`json: "message"`
   Result	[]Result	`json:"result"`
}

type Result struct {
   Name		string		`json:"name"`
   Location	Location	`json:"location"`
   Uid		string		`json:"uid"`
   Province	string		`json:"province"`
   City		string		`json:"city"`
   District	string		`json:"district"`
   Business	string		`json:"business"`
   Cityid	string		`json:"cityid"`
   Tag		string		`json:"tag"`
   Address	string		`json:"address"`
   Children	[]Child		`json:"children"`
   Adcode	string		`json:"adcode"`
}

type Location struct {
   Lat       float64       `json:"lat"`
   Lng       float64       `json:"lng"`
}

type Child struct {
   Uid			string    `json:"uid"`
   Name			string    `json:"name"`
   Show_name  	string    `json:"show_name"`
}

func main() {
	url := "https://api.map.baidu.com/place/v2/suggestion?query=天安门&region=北京&city_limit=true&output=json&ak=pqnjDWUVvNlGj7vVdxhzD6zLoi0Df1bG"

	//发送get请求
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer resp.Body.Close()

	//使用Decode解码
	var result Response	//可以不初始化，Decode会帮我们初始化
	err = json.NewDecoder(resp.Body).Decode(result)
	if err != nil {
		fmt.Println(err)
		return
	}
    
    //使用Unmarshal解码
	body, err := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(body, result)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("%#v\n", result)
}
```

> 注意结构体字段要大写，不然`encoding/json`无法访问相应的字段，这是个大坑



案例：

```go
/**
	map与json的相互转换
 */
func main() {
	var jsonString = `{
		"name": "Gopher",
		"title": "programmer",
		"contact": {
			"home": "415.333.3333",
			"cell": "415.555.5555"
		}
	}`

	var target map[string]interface{}
	//将json转成map
	err := json.Unmarshal([]byte(jsonString), &target)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("name:", target["name"])
	fmt.Println("title:", target["title"])
	fmt.Println("contact:")
	fmt.Println("home:", target["contact"].(map[string]interface{})["home"])
	fmt.Println("cell:", target["contact"].(map[string]interface{})["cell"])

	//将map转成json
	jsonByte, err := json.Marshal(target)
	fmt.Println(string(jsonByte))
}
```



### 编码

#### marshal

```go
func Marshal(v interface{}) ([]byte, error)
```

Marshal函数返回v的json编码。



案例：

```go
import (
    //json的包名
	"encoding/json"	
	"fmt"
)

type Student struct {
	Id int
	Name string
	Gender string
}

type Class struct {
	Name string
	Students []*Student
}

func main() {
	class := &Class {
		Name: "3年一班",
		Students: make([]*Student, 0, 200),
	}

	for i:= 0; i < 10; i++ {
		stu := &Student {
			Id: i,
			Name: fmt.Sprintf("%02d",i),
			Gender: "男",
		}
		class.Students = append(class.Students,stu)
	}

	//JSON序列化
	data, err := json.Marshal(class)
	if err != nil {
		fmt.Println("序列化失败!")
		return
	}
	s := fmt.Sprintf("%s",data)
	fmt.Println(string(data))

	//反序列化
	class1 := &Class{}
	err = json.Unmarshal([]byte(s), class1)
	if err != nil {
		fmt.Println("反序列化失败!")
		return
	}
	fmt.Printf("%#v",class1)
}
```

> **使用json.Marshal和json.Unmarshal分别进行序列化和反序列化**



### Indent

```go
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
```

`json.Indent()`能够格式化json，prefix能设置前缀，indent能设置缩进

```go
//
//  TestIndent
//  @Description: 测试json.Indent()
//  @param t
//
func TestIndent(t *testing.T) {
	//创建匿名结构体变量
	var person struct{
		Name 	string
		Age		int
	}
	person.Name = "郑晓颖"
	person.Age = 22

	//序列化person
	jsonStr, err := json.Marshal(person)
	if err != nil {
		fmt.Println("序列化失败", err)
		return
	}
	fmt.Println("Before:")
	fmt.Println(string(jsonStr))

	//格式化json
	var buff bytes.Buffer
	err = json.Indent(&buff, jsonStr, "", "\t")	//此处设置无前缀，每行缩进为"\t"
	fmt.Println("After:")
	fmt.Println(buff.String())
}
```

输出结果：

```go
Before:
{"Name":"郑晓颖","Age":22}
After:
{
	"Name": "郑晓颖",
	"Age": 22
}
```





## 单元测试



### 坑

- **单元测试中的文件路径均要以单元测试文件为起始**



### 基础单元测试

```go
const pass = "\u2713"   //打勾
const fail = "\u2717"  //打X

func TestDownload(t *testing.T) {
   url := "https://api.map.baidu.com/place/v2/suggestion?query=天安门&region=北京&city_limit=true&output=json&ak=pqnjDWUVvNlGj7vVdxhzD6zLoi0Df1bG"
   statusCode := 200

   t.Log("测试下载功能")
   {
      resp, err := http.Get(url)
      if err != nil {
         t.Fatal("测试结果:", fail, err)
         return
      }
      defer resp.Body.Close()

      if resp.StatusCode == statusCode {
         t.Log("测试结果:", pass, statusCode)
      } else {
         t.Log("测试结果:", fail, statusCode)
      }
   }
}
```



### 只测试单个函数

```shell
go test -v book_test.go -run TestBookModel
```

> `-run`后加要测试的函数



## flag

flag用来接收命令行参数



### flag 参数类型

flag 包支持的命令行参数类型有 bool、int、int64、uint、uint64、float、float64、string、duration，如下表所示：

| flag 参数      | 有效值                                                       |
| -------------- | ------------------------------------------------------------ |
| 字符串 flag    | 合法字符串                                                   |
| 整数 flag      | 1234、0664、0x1234 等类型，也可以是负数                      |
| 浮点数 flag    | 合法浮点数                                                   |
| bool 类型 flag | 1、0、t、f、T、F、true、false、TRUE、FALSE、True、False      |
| 时间段 flag    | 任何合法的时间段字符串，如“300ms”、“-1.5h”、“2h45m”， 合法的单位有“ns”、“us”、“µs”、“ms”、“s”、“m”、“h” |



### 接收命令行参数的方法

- #### flag.Type()

  `flag.Type()`可以定义一个用来接收命令行参数的变量，基本格式如下：

  ```
  flag.Type(flag 名, 默认值, 帮助信息) *Type
  ```

  Type 可以是 Int、String、Bool 等，返回值为一个相应类型的指针

  ```
  flag.String() *string
  flag.Int() *int
  ...
  ```

- #### flag.TypeVar()

  `flag.TypeVar()`能将 flag 绑定到一个已有变量上，基本格式如下：

  ```
  flag.TypeVar(Type 指针, flag 名, 默认值, 帮助信息)
  ```

  TypeVar 可以是 IntVar、StringVar、BoolVar 等,无返回值

  ```
  flag.IntVar()
  flag.Stringvar()
  ...
  ```

> 使用`flag.Type()`得到的是指针类型的变量，使用`flag.TypeVar()`得到的是值类型的变量

### flag.Parse()

`flag.Parse()`解析命令行参数并存储到已绑定好的变量,**必须在所有flag都注册好而未访问其值时执行。未注册却使用flag -help时，会返回ErrHelp**



### 常用函数

```go
flag.Args()  //返回未被解析的参数，以 []string 类型
flag.NArg()  //返回未被解析的参数个数
flag.NFlag() //返回被解析的参数个数
```



案例：

```go
//直接返回变量指针
var id = flag.String("id", "0", "id")
var name = flag.String("name", "郑晓颖", "name")
var age = flag.Int("age", 22, "age")
var other int

func init() {
   //将flag与现有变量绑定
   flag.IntVar(&other, "other", 1, "other")
}

func main() {
   //解析运行命令参数到指定的变量
   flag.Parse()
   fmt.Println("没被解析的变量:", flag.Args())
   fmt.Println("没被解析的变量数:", flag.NArg())
   fmt.Println("被解析的变量数:", flag.NFlag())
   for i := 0; i < flag.NArg(); i++ {
      fmt.Println(flag.Args()[i])
   }
   fmt.Println("id:", *id)
   fmt.Println("name:", *name)
   fmt.Println("age:", *age)	//这里是指针
   fmt.Println("other:", other)	//这里是值
}
```

使用命令行执行

```go
go run flag.go -id 1 -name "郑兵颖" -age 23 -other 0 333	//这里333是不被解析的参数
```

使用goland执行

![image-20211123160131182](Go开发笔记.assets\image-20211123160131182.png)

结果

![image-20211123160238128](Go开发笔记.assets\image-20211123160238128.png)





## go-zero

### 准备工作

- 安装 `protoc-gen-go`

  ```
  go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2
  ```

- 安装 `protoc`

  ```
  wget https://github.com/protocolbuffers/protobuf/releases/download/v3.14.0/protoc-3.14.0-linux-x86_64.zip
  unzip protoc-3.14.0-linux-x86_64.zip
  mv bin/protoc /usr/local/bin/
  ```

- 安装 goctl 工具

  ```
  GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/tal-tech/go-zero/tools/goctl
  ```



### 开发流程

- 创建api模板文件，并编写api

  ```
  goctl api -o test.api
  ```

- 根据编写好的api生成api代码

  ```
  goctl api go -api test.api -dir .
  ```

- 测试api

  ```
  go run test.go -f etc/test-api.yaml
  ```

- 编写业务代码



### Tag

 tag定义和golang中json tag语法一样，除了json tag外，go-zero还提供了另外一些tag来实现对字段的描述， 详情见下表。

| tag key | 描述                                                         | 提供方  | 有效范围          | 示例            |
| ------- | ------------------------------------------------------------ | ------- | ----------------- | --------------- |
| json    | json序列化tag                                                | golang  | request、response | `json:"fooo"`   |
| path    | 路由path，如`/foo/:id`                                       | go-zero | request           | `path:"id"`     |
| form    | 标志请求体是一个form（POST方法时）或者一个query(GET方法时`/search?name=keyword`) | go-zero | request           | `form:"name"`   |
| header  | HTTP header，如 `Name: value`                                | go-zero | request           | `header:"name"` |

- path

  ```go
  type TestReq struct {
  	Id int `path:"id"`
  }
  
  //在service中定义相应的路由,id会作为参数传给TestReq
  get /:id(TestReq)
  
  localhost:8888/3	//TestReq.Id=3
  localhost:8888/4	//TestReq.Id=4
  localhost:8888/5	//TestReq.Id=5
  ```

- form

  ```go
  type TestReq struct {
  	Id int `form:"id"`
  }
  
  get /test(TestReq)
  
  localhost:8888/test?id=1	//TestReq.Id=1
  localhost:8888/test?id=2	//TestReq.Id=2
  localhost:8888/test?id=3	//TestReq.Id=3
  ```

- json

  ```go
  type TestReq struct {
  	Id int `json:"id"`
  }
  
  get /test(TestReq)
  ```

  使用postman测试接口

  - 设置headers

    ![image-20211126093947043](Go开发笔记.assets\image-20211126093947043.png)

  - 编写测试json

    ![image-20211126094028933](Go开发笔记.assets\image-20211126094028933.png)



### tag修饰符

常见参数校验描述

| tag key  | 描述                                  | 提供方  | 有效范围 | 示例                         |
| -------- | ------------------------------------- | ------- | -------- | ---------------------------- |
| optional | 定义当前字段为可选参数                | go-zero | request  | `json:"name,optional"`       |
| options  | 定义当前字段的枚举值,多个以竖线\|隔开 | go-zero | request  | `json:"gender,options=male"` |
| default  | 定义当前字段默认值                    | go-zero | request  | `json:"gender,default=male"` |
| range    | 定义当前字段数值范围                  | go-zero | request  | `json:"age,range=[0:120]"`   |

- optional

  ```go
  type TestReq struct {
  	Id		int 	`json:"id"`
  	Name	string	`json:"name,optional"`
  }
  
  get /test(TestReq)
  ```

  请求json

  ```json
  {
      "id":"30"	//即使少了Name字段也不报错
  }
  ```

  







## gorm



### 表名TableName

您可以实现 `Tabler` 接口来更改默认表名，例如：

```go
type Tabler interface {
    TableName() string
}

// TableName 会将 User 的表名重写为 `profiles`
func (User) TableName() string {
  return "profiles"
}
```



### 列名

根据约定，数据表的列名使用的是 struct 字段名的 `蛇形命名`

```
type User struct {
  ID        uint      // 列名是 `id`
  Name      string    // 列名是 `name`
  Birthday  time.Time // 列名是 `birthday`
  CreatedAt time.Time // 列名是 `created_at`
}
```

您可以使用 `column` 标签或 [`命名策略`](https://gorm.io/zh_CN/docs/conventions.html#naming_strategy) 来覆盖列名

```
type Animal struct {
  AnimalID int64     `gorm:"column:beast_id"`         // 将列名设为 `beast_id`
  Birthday time.Time `gorm:"column:day_of_the_beast"` // 将列名设为 `day_of_the_beast`
  Age      int64     `gorm:"column:age_of_the_beast"` // 将列名设为 `age_of_the_beast`
}
```





## gjson



### 安装

```go
go get github.com/tidwall/gjson
```



### Get

根据指定路径搜索json串

```go
func Get(json, path string) Result
```

```json
{
    "name": {"first": "Tom", "last": "Anderson"},
    "age":37,
    "children": ["Sara","Alex","Jack"],
    "friends": [
      {"first": "James", "last": "Murphy"},
      {"first": "Roger", "last": "Craig"}
    ]
}
```

- 通过`.`来分割路径

  ```
  "name.last"          >> "Anderson"
  ```

- 可以使用通配符`*`和`?`，也可以使用转义字符`\`对它们转义

- 通过下标访问数组元素

  ```go
  "children.1"         >> "Alex"
  "child*.2"           >> "Jack"
  "c?ildren.0"         >> "Sara"
  ```

- 通过`#`获取数组元素个数或者遍历

  ```go
  "children.#"         >> 3					//获取元素个数
  "friends.#.first"    >> ["James","Roger"]	//遍历
  ```

- 直接获取元素

  ```go
  "children"           >> ["Sara","Alex","Jack"]
  ```

  ```go
  s1 := `{
     "name": {"first": "Tom", "last": "Anderson"},
     "age":37,
     "children": ["Sara","Alex","Jack"],
     "friends": [
       {"first": "James", "last": "Murphy"},
       {"first": "Roger", "last": "Craig"}
     ]
  }`
  
  name := gjson.Get(s1, "name")
  name_last := gjson.Get(s1, "name.last")
  children_1 := gjson.Get(s1, "children.1")
  chil_1 := gjson.Get(s1, "chil*.1")
  chil_ren_1 := gjson.Get(s1, "chil?ren.1")
  children_num := gjson.Get(s1, "children.#")
  children := gjson.Get(s1, "friends.#.first")
  
  fmt.Println("name:", name)					//name: {"first": "Tom", "last": "Anderson"}
  fmt.Println("name_last:", name_last)		//name_last: Anderson
  fmt.Println("children_1:", children_1)		//children_1: Alex
  fmt.Println("chil_1:", chil_1)				//chil_1: Alex
  fmt.Println("chil_ren_1:", chil_ren_1)		//chil_ren_1: Alex
  fmt.Println("chilren_num:", children_num)	//chilren_num: 3
  fmt.Println("chilren:", children)			//chilren: ["James","Roger"]
  ```

  



## resty

### 安装

```go
go get -u github.com/go-resty/resty/v2
```





## redis

### 安装

#### windows

redis官方不推荐在windows下使用redis，所以在windows下没有官方版本，不过可以用其他人维护的版本

```go
https://github.com/tporadowski/redis/releases
```

这里我们不下载安装包，而是下载源码后解压运行

```go
Redis-x64-5.0.14.zip
```

在解压目录下运行

```go
redis-server.exe redis.windows.conf
```

即可启动redis服务端，如果不加`redis.windows.conf`则会使用默认的配置文件，所以这里可以省略

启动服务端后再另起一个窗口，运行

```cmd
redis-cli.exe -h 127.0.0.1 -p 6379
```

即可启动客户端对服务端进行操作



#### linux

安装redis

```go
sudo apt update
sudo apt install redis-server
```

启动redis-server

```
redis-server
```

验证server是否启动成功，新开一个终端

```
redis-cli
```

输入ping，如果返回pong说明启动成功



### 配置文件

#### 获取配置文件路径

```
service redis status
```

![image-20220101202916195](Go开发笔记.assets/image-20220101202916195.png)

```
cat /lib/systemd/system/redis-server.service
```

![image-20220101203032845](Go开发笔记.assets/image-20220101203032845.png)

这里便是redis配置文件的路径



#### 修改配置

修改redis配置有两种方法，一种是直接修改redis配置文件，另一种是通过redis客户端redis-cli修改

```
redis-cli				//启动redis客户端
config get *			//获取所有配置
config set 属性名 属性值	//修改配置
```

> 在redis客户端修改的配置在只在本次redis运行时有效，并且有一些配置在redis运行时无法修改，比如端口号`port`,只能说鸡肋



#### 常用配置项

| 序号 | 配置项                                                       | 说明                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | `daemonize no`                                               | Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） |
| 2    | `pidfile /var/run/redis.pid`                                 | 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 |
| 3    | `port 6379`                                                  | 指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字 |
| 4    | `bind 127.0.0.1`                                             | 绑定的主机地址                                               |
| 5    | `timeout 300`                                                | 当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能  |
| 6    | `loglevel notice`                                            | 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice |
| 7    | `logfile stdout`                                             | 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null |
| 8    | `databases 16`                                               | 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id |
| 9    | `save <seconds> <changes>`Redis 默认配置文件中提供了三个条件：**save 900 1****save 300 10****save 60 10000**分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 | 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 |
| 10   | `rdbcompression yes`                                         | 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 |
| 11   | `dbfilename dump.rdb`                                        | 指定本地数据库文件名，默认值为 dump.rdb                      |
| 12   | `dir ./`                                                     | 指定本地数据库存放目录                                       |
| 13   | `slaveof <masterip> <masterport>`                            | 设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 |
| 14   | `masterauth <master-password>`                               | 当 master 服务设置了密码保护时，slav 服务连接 master 的密码  |
| 15   | `requirepass foobared`                                       | 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭 |
| 16   | ` maxclients 128`                                            | 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 |
| 17   | `maxmemory <bytes>`                                          | 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 |
| 18   | `appendonly no`                                              | 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no |
| 19   | `appendfilename appendonly.aof`                              | 指定更新日志文件名，默认为 appendonly.aof                    |
| 20   | `appendfsync everysec`                                       | 指定更新日志条件，共有 3 个可选值：**no**：表示等操作系统进行数据缓存同步到磁盘（快）**always**：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）**everysec**：表示每秒同步一次（折中，默认值） |
| 21   | `vm-enabled no`                                              | 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制） |
| 22   | `vm-swap-file /tmp/redis.swap`                               | 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 |
| 23   | `vm-max-memory 0`                                            | 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 |
| 24   | `vm-page-size 32`                                            | Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 |
| 25   | `vm-pages 134217728`                                         | 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 |
| 26   | `vm-max-threads 4`                                           | 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 |
| 27   | `glueoutputbuf yes`                                          | 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 |
| 28   | `hash-max-zipmap-entries 64 hash-max-zipmap-value 512`       | 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 |
| 29   | `activerehashing yes`                                        | 指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） |
| 30   | `include /path/to/local.conf`                                | 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 |



### 中文乱码

- 终端乱码

  redis-cli终端默认不转义中文，所以需要在启动终端的时候需要手动指定

  ```
  redis-cli --raw
  ```

  



### 数据类型

#### 字符串`string`

```
127.0.0.1:6379> set s helloworld
OK
127.0.0.1:6379> get s
"helloworld"
127.0.0.1:6379> set s "h"
OK
127.0.0.1:6379> get s
"h"
127.0.0.1:6379> set s 's'
OK
127.0.0.1:6379> get s
"s"
127.0.0.1:6379> set s `s`
OK
127.0.0.1:6379> get s
"`s`"

set s s2 nx		//nx: 只有当变量不存在时才能设置成功
set s2 3 xx		//xx: 只有当变量存在时才能设置成功

//自增
127.0.0.1:6379> set s1 0
OK
127.0.0.1:6379> get s1
"0"
127.0.0.1:6379> incr s1		//自增1
(integer) 1
127.0.0.1:6379> incrby s1 500	//根据步长自增
(integer) 501
127.0.0.1:6379> get s1
"501"
127.0.0.1:6379> set s2 a	//只有数字类型能自增
OK
127.0.0.1:6379> incr s2
(error) ERR value is not an integer or out of range
127.0.0.1:6379> incrby s2 2
(error) ERR value is not an integer or out of range

//自减
127.0.0.1:6379> set s1 0
OK
127.0.0.1:6379> decr s1		//自减1
(integer) -1
127.0.0.1:6379> decr s1
(integer) -2
127.0.0.1:6379> decrby s1 2	//根据步长自减
(integer) -4
127.0.0.1:6379> decrby s1 100
(integer) -104
127.0.0.1:6379> set s1 100
OK
127.0.0.1:6379> decrby s1 101
(integer) -1


//getset
//获取原值并将key更新为新值
127.0.0.1:6379> set s1 0
OK
127.0.0.1:6379> get s1
"0"
127.0.0.1:6379> getset s1 2
"0"
127.0.0.1:6379> get s1
"2"

//mset
//批量赋值
127.0.0.1:6379> mset s1 “s1” s2 “s2” s3 “s3”
OK

//mget
//批量取值
127.0.0.1:6379> mget s1 s2 s3
1) "s1"
2) "s2"
3) "s3"

//exists
//判断元素存不存在，0-不存在，1-存在
127.0.0.1:6379> set s1 a1
OK
127.0.0.1:6379> get s1
"a1"
127.0.0.1:6379> exists s1
(integer) 1

//del
//删除元素，0-删除失败，1-删除成功
127.0.0.1:6379> del s1
(integer) 1
127.0.0.1:6379> exists s1
(integer) 0
127.0.0.1:6379> get s1
(nil)

//type
//获取元素类型
127.0.0.1:6379> set s1 a1
OK
127.0.0.1:6379> type s1
string
127.0.0.1:6379> del s1
(integer) 1
127.0.0.1:6379> type s1
none

//expire
//设置元素存活时间，超出时间后元素会变删除，以秒为单位
127.0.0.1:6379> set s1 a
OK
127.0.0.1:6379> expire s1 5
(integer) 1
127.0.0.1:6379> get s1
"a"
127.0.0.1:6379> get s1
(nil)

//ex
//在创建元素时设置元素存活时间，以秒为单位
127.0.0.1:6379> set s1 a ex 5
OK
127.0.0.1:6379> get s1
"a"
127.0.0.1:6379> get s1
(nil)


//px
//在创建元素时设置元素存活时间，以毫秒为单位
127.0.0.1:6379> set s1 a px 3000
OK
127.0.0.1:6379> get s1
"a"
127.0.0.1:6379> get s1
(nil)


//ttl
//查看元素剩余存活时间
127.0.0.1:6379> set s1 a ex 9
OK
127.0.0.1:6379> ttl s1
(integer) 6
```



#### list

redis的`list`基于`Linked Lists`实现。

```
//rpush
//往list的尾部添加元素
127.0.0.1:6379> rpush list1 A B C D E F
(integer) 6

//lrange
//获取list指定区间内的元素 [a,b]区间为左闭右闭区间
//0-第一个元素 -1-最后一个元素 -2-倒数第二个元素
127.0.0.1:6379> lrange list1 0 5
1) "A"
2) "B"
3) "C"
4) "D"
5) "E"
6) "F"

//lpush
//往list的头部添加元素
127.0.0.1:6379> lpush list1 C
(integer) 7
127.0.0.1:6379> lrange list1 0 -1
1) "C"
2) "A"
3) "B"
4) "C"
5) "D"
6) "E"
7) "F"

//rpop
//将元素从队列右侧出队，并返回该元素
127.0.0.1:6379> rpop list1
"F"
127.0.0.1:6379> lrange list1 0 -1
1) "C"
2) "A"
3) "B"
4) "C"
5) "D"
6) "E"


//lpop
//左侧出队
127.0.0.1:6379> lpop list1
"C"
127.0.0.1:6379> lrange list1 0 -1
1) "A"
2) "B"
3) "C"
4) "D"
5) "E"


//当队列中没有元素时，队列会被自动删除，此时再进行pop操作，会返回nil
127.0.0.1:6379> exists list1
(integer) 0
127.0.0.1:6379> lpop list1
(nil)


//ltrim
//ltrim能用一个区间截断队列，该区间为左闭右闭区间
127.0.0.1:6379> rpush list1 A B C D E F G
(integer) 7
127.0.0.1:6379> lrange list1 0 -1
1) "A"
2) "B"
3) "C"
4) "D"
5) "E"
6) "F"
7) "G"
127.0.0.1:6379> ltrim list1 0 2
OK
127.0.0.1:6379> lrange list1 0 -1
1) "A"
2) "B"
3) "C"

//1、当key的值为空时，redis会自动删除该key
//2、当我们往一个聚合结构添加元素时，如果该聚合结构为空，则会自动创建该聚合结构

//llen
//获取list的长度
127.0.0.1:6379> lrange list1 0 -1
1) "A"
2) "B"
3) "C"
127.0.0.1:6379> llen list1
(integer) 3
```





#### hash

```redis
//hmset key field val [field val]
//hmset创建一个hashmap
127.0.0.1:6379> hmset map1 name 郑晓颖 age 18
OK

//hget
//hget能获取map中一个字段
127.0.0.1:6379> hget map1 name
郑晓颖

//hgetall
//hgetall能获取map中的所有字段
127.0.0.1:6379> hgetall map1
name
郑晓颖
age
18

//hmget key field [field]
//hmget能获取多个指定字段的值
127.0.0.1:6379> hmget map1 name sex
郑兵颖
男


//hincrby
//hincrby能单独对map中的某个字段进行自增
127.0.0.1:6379> hincrby map1 age 10
28
127.0.0.1:6379> hgetall map1
name
郑兵颖
age
28
sex
男

```



## goland远程调试

### 起因

现在工作环境需要用到linux，开发环境也都搭建在虚拟机上面，而如果直接在虚拟机上开发的话需要给虚拟机分配较多的内存，会导致卡顿，直接在windows上开发的话则需要先在windows改完代码，再把代码上传到gitee上，再在linux上把代码下载下来编译测试，比较麻烦。



### 好处

使用goland远程调试，能够直接在windows上修改代码，goland会自动帮你把代码修改上传到linux的项目上，省时省力，同时goland远程调试还支持远程debug虚拟机上的项目



### 配置

- 虚拟机配置好go环境

- 虚拟机安装调试工具`dlv`

- goland配置sftp代码同步

  ![image-20211220092317508](Go开发笔记.assets/image-20211220092317508.png)

  ![image-20211220092350373](Go开发笔记.assets/image-20211220092350373.png)

  勾选自动上传Goland菜单: Tools -> Deployment -> Auto Upload(Always)

- linux开启dlv调试服务

  ```bash
  cd ~/workspace/goworks/src/safetytools/api # golang 代码目录
  go build -o ../safetytools # 编译golang代码
  dlv --listen=:2345 --headless=true --api-version=2 exec ~/workspace/goworks/src/safetytools/safetytools # 开启delve服务
  ```

- goland配置远程debug

  ![image-20211220093000662](Go开发笔记.assets/image-20211220093000662.png)

- 配置完成后，现在linux运行dlv，再在goland点击debug即可远程调试



## linux

### 配置网络

- ubuntu18.04

  ```
  vim /etc/netplan/01-network-manager-all.yaml
  
  //配置文件内容
  network:
    version: 2
    #renderer: NetworkManager
    ethernets:
            ens33:
                    dhcp4: no
                    dhcp6: no
                    addresses: [10.7.3.197/24]
                    gateway4: 10.7.3.254
                    nameservers:
                            addresses: [10.7.0.10, 10.7.0.12]
  
  //让配置文件生效
  sudo netplan apply
  ```

  

### 设置代理

- 设置系统代理

  ```
  vim /etc/profile
  
  //新增代理配置
  #代理
  export http_proxy="http://10.7.3.67:8080"
  export https_proxy="http://10.7.3.67:8080"
  
  source /etc/profile
  ```

- 设置apt代理

  ```
  //新建apt配置文件
  sudo touch /etc/apt/apt.conf.d/proxy.conf
  
  vim proxy.conf
  
  //新增两行
  Acquire {
  HTTP::proxy "http://10.7.3.67:8080";
  HTTPS::proxy "http://10.7.3.67:8080";
  }
  
  sudo apt update
  ```

  